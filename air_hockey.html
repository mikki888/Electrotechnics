<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2D Аерохокей v17 - Графіка + Просунутий ШІ + Автоприховування</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            margin: 0;
            background-color: #222;
            flex-direction: column;
            font-family: sans-serif;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            overflow: hidden;
            color: white;
        }
        canvas {
            border: 2px solid #aaa;
            display: block;
            cursor: grab;
            touch-action: none;
            max-width: 100%;
            max-height: 100%;
            box-sizing: border-box;
        }
        canvas.grabbing {
            cursor: grabbing;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9em;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            /* Стилі для автоприховування */
            transition: opacity 0.5s ease-in-out; /* Плавність появи/зникнення */
            opacity: 1; /* Початково видимі */
            pointer-events: auto; /* Початково можна взаємодіяти */
        }
        .controls.hidden {
            opacity: 0; /* Робимо невидимими */
            pointer-events: none; /* Забороняємо взаємодію, коли приховані */
        }
        .control-group label {
            margin-right: 5px;
            white-space: nowrap;
        }
        #speedValue, #puckSpeedValue, #gripValue {
            font-weight: bold;
        }
        @media (max-width: 550px) {
            .controls {
                gap: 8px;
            }
            .control-group input[type=range] {
                width: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label for="difficulty">Складність:</label>
            <select id="difficulty">
                <option value="easy">Легка</option>
                <option value="medium" selected>Середня</option>
                <option value="hard">Важка</option>
            </select>
        </div>
        <div class="control-group">
             <label for="aiSpeed">Шв. ШІ: <span id="speedValue">1.0</span>x</label>
             <input type="range" id="aiSpeed" min="0.2" max="2.5" value="1.0" step="0.1" style="width: 80px;">
        </div>
        <div class="control-group">
             <label for="puckSpeedSlider">Макс. шв. шайби: <span id="puckSpeedValue">15</span></label>
             <input type="range" id="puckSpeedSlider" min="5" max="35" value="15" step="1" style="width: 80px;">
        </div>
         <div class="control-group">
             <label for="gripSlider">Зачепл.: <span id="gripValue">0.5</span></label>
             <input type="range" id="gripSlider" min="0.0" max="0.8" value="0.5" step="0.01" style="width: 80px;">
        </div>
        <!-- НОВИЙ СЛАЙДЕР -->
        <div class="control-group">
            <label for="bounceSlider">Відск. ключ.: <span id="bounceValue">0.80</span></label>
            <input type="range" id="bounceSlider" min="0.4" max="0.95" value="0.8" step="0.01" style="width: 80px;">
        </div>
    </div>

    <script>
        // --- Глобальні налаштування ---
        let canvasElement; let isPortrait = false; const padding = 10;

        // Кольори та Розміри
        const playerColor = [0, 100, 255]; const aiColor = [255, 50, 50]; const puckColor = [240, 240, 240];
        const fieldColor = [45, 45, 55]; const scoreColor = [200, 200, 200, 80];
        let paddleRadius; let puckRadius; let goalWidth;

        // Фізика
        const friction = 0.995;
        let currentMaxPuckSpeed = 20;
        let currentEdgeBlendFactor = 0.39;
        const wallRestitution = -0.95; // Відскок від стін залишається константою
        let currentPaddleRestitution = 0.8; // НОВА ЗМІННА для відскоку від ключки
        const initialPaddleRestitutionCenter = 0.8; // Базове значення для центру
        const initialPaddleRestitutionEdge = 0.6;   // Базове значення для краю

        // --- Об'єкти гри ---
        let player; let ai; let puck;

        // --- Стан гри ---
        let playerScore = 0; let aiScore = 0; let difficulty = 'medium'; let isDragging = false;

        // --- Налаштування ШІ ---
        let aiGlobalSpeedMultiplier = 1.0;
        const overallSpeedBaseMultiplier = 0.392;
        const reactionSpeedModifier = 0.7;
        let aiBasePos; let aiDefensiveLine; let aiCriticalDefenseLine; let aiOffensivePush;
        const aiAimAssist = 0.1; let cornerCheckRadius; const wallAvoidanceDistance = 50;
        const wallAvoidanceForce = 0.2; let scaledWallAvoidDistance;

        // Параметри застрягання
        const STUCK_INITIAL_THRESHOLD_FRAMES = 45; const STUCK_ESCAPE_TIMEOUT_FRAMES = 300;
        const STUCK_ESCAPE_FORCE_MULTIPLIER = 4.5;

        // Параметри ШІ v11
        const AI_PREDICTION_FRAMES_MIN = 8; const AI_PREDICTION_FRAMES_MAX = 25;
        const AI_DEFENSE_CLEAR_BIAS = 0.25; const AI_CRITICAL_CLEAR_STRENGTH = 1.0;

        // --- Нові змінні для графіки ---
        let puckTrail = []; const TRAIL_LENGTH = 12;
        let hitSparks = []; const SPARK_LIFETIME = 15; const NUM_SPARKS = 5;
        let goalFlash = { active: false, side: null, timer: 0 }; const GOAL_FLASH_DURATION = 20;

        // --- Змінні для автоприховування панелі керування ---
        let controlsElement;
        let controlsHideTimeout = null; // Зберігатиме ID таймера setTimeout
        const CONTROLS_HIDE_DELAY = 2500; // Затримка в мілісекундах (2.5 секунди)

        // --- Функція налаштування p5.js ---
        function setup() {
            let dims = calculateCanvasSize();
            canvasElement = createCanvas(dims.w, dims.h);
            canvasElement.parent(document.body);
            // isPortrait визначається в resetLayout
            textAlign(CENTER, CENTER);
            noStroke();
            resetLayout(); // Викликаємо тут, щоб встановити isPortrait та початкові розміри/позиції
            setupEventListeners();
            noiseSeed(random(1000));
            controlsElement = document.querySelector('.controls'); // Знаходимо елемент
            showControls(); // Показати панель при старті
        }

        // --- Розрахунок розміру канвасу ---
        function calculateCanvasSize() {
            let availableWidth = windowWidth - padding * 2;
            let availableHeight = windowHeight - padding * 2 - 70; // Враховуємо висоту панелі керування (приблизно)
            availableHeight = max(availableHeight, 200); // Мінімальна висота
            // Орієнтація визначається безпосередньо перед використанням у resetLayout
            return { w: floor(availableWidth), h: floor(availableHeight) }; // Повертаємо тільки розміри
        }

       // --- Скидання/Ініціалізація розмірів та позицій ---
        function resetLayout() {
            // Визначаємо isPortrait на основі поточних розмірів полотна (width, height)
            isPortrait = height > width;
          //console.log(`Resetting layout. Width: ${width}, Height: ${height}, Portrait: ${isPortrait}`);
            let minDim = min(width, height);
            let maxDim = max(width, height); // Додамо для обмеження

            // Розраховуємо БАЗОВІ розміри
            let basePaddleRadius = max(25, minDim * 0.05);
            let basePuckRadius = max(10, minDim * 0.03);

            // Застосовуємо множник ТІЛЬКИ в портретному режимі
            const portraitSizeMultiplier = 1.4;
            if (isPortrait) {
                paddleRadius = basePaddleRadius * portraitSizeMultiplier;
                puckRadius = basePuckRadius * portraitSizeMultiplier;
              //console.log(`Portrait mode: Applying ${portraitSizeMultiplier}x size multiplier.`);
            } else {
                paddleRadius = basePaddleRadius;
                puckRadius = basePuckRadius;
              //console.log(`Landscape mode: Using base sizes.`);
            }

            // Додаткове обмеження максимального розміру, щоб уникнути надто великих об'єктів
            const maxPaddleRelWidth = 0.12;
            const maxPuckRelWidth = 0.06;
            if (isPortrait) {
                 paddleRadius = min(paddleRadius, width * maxPaddleRelWidth);
                 puckRadius = min(puckRadius, width * maxPuckRelWidth);
            } else {
                 paddleRadius = min(paddleRadius, minDim * 0.1); // Обмеження для альбомного
                 puckRadius = min(puckRadius, minDim * 0.05);   // Обмеження для альбомного
            }
          //console.log(`Final Clamped Sizes: Paddle=${paddleRadius.toFixed(1)}, Puck=${puckRadius.toFixed(1)}`);


            // Інші розрахунки, що залежать від розмірів
            goalWidth = minDim * 0.3;
            aiOffensivePush = paddleRadius * 0.7;
            cornerCheckRadius = paddleRadius * 1.8;
            scaledWallAvoidDistance = minDim * 0.13;

            // Ініціалізуємо об'єкти ПІСЛЯ визначення всіх розмірів
            initializeObjects(false); // false - не скидання після голу

            isDragging = false;
            if (canvasElement) {
                 canvasElement.removeClass('grabbing');
            }
            puckTrail = [];
            hitSparks = [];
            goalFlash.active = false;
            showControls(); // Показати панель при зміні розміру/орієнтації
        }


        // --- Ініціалізація ігрових об'єктів (з урахуванням isPortrait) ---
        function initializeObjects(aiJustScoredOrStuck = false) {
           //console.log(`Initializing objects. Portrait: ${isPortrait}`); // Додамо лог для перевірки

             let playerStartX, playerStartY;
             let aiStartX, aiStartY;

             // Визначаємо базові позиції та лінії ЗАЛЕЖНО від орієнтації
             if (isPortrait) {
                // Портретний режим: Гравець знизу, ШІ зверху
                playerStartX = width / 2;
                playerStartY = height * 0.75;
                aiBasePos = { x: width / 2, y: height * 0.25 };
                aiDefensiveLine = height * 0.40;
                aiCriticalDefenseLine = height * 0.18;
                aiStartX = aiBasePos.x;
                aiStartY = aiBasePos.y;
              //console.log("Setting up for PORTRAIT mode.");

             } else {
                // Альбомний режим: Гравець зліва, ШІ справа
                playerStartX = width * 0.25;
                playerStartY = height / 2;
                aiBasePos = { x: width * 0.75, y: height / 2 };
                aiDefensiveLine = width * 0.60;
                aiCriticalDefenseLine = width * 0.82;
                aiStartX = aiBasePos.x;
                aiStartY = aiBasePos.y;
              //console.log("Setting up for LANDSCAPE mode.");
             }

             // Створюємо або оновлюємо Гравця
             if (player) {
                 player.x = playerStartX; player.y = playerStartY;
                 player.prevX = playerStartX; player.prevY = playerStartY;
                 player.velX = 0; player.velY = 0;
                 player.r = paddleRadius; // Оновлюємо радіус при реініціалізації
             } else {
                 player = { x: playerStartX, y: playerStartY, r: paddleRadius, color: playerColor, prevX: playerStartX, prevY: playerStartY, velX: 0, velY: 0 };
             }

             // Створюємо або оновлюємо ШІ
             if (ai) {
                 ai.x = aiStartX; ai.y = aiStartY;
                 ai.prevX = aiStartX; ai.prevY = aiStartY;
                 ai.velX = 0; ai.velY = 0;
                 ai.r = paddleRadius; // Оновлюємо радіус
                 ai.stuckInCornerTimer = 0;
                 ai.lastPuckPosInCorner = { x: -1, y: -1 };
                 ai.isStuckEscaping = false;
                 ai.escapeAttemptTimer = 0;
             } else {
                  ai = {
                      x: aiStartX, y: aiStartY, r: paddleRadius, color: aiColor,
                      prevX: aiStartX, prevY: aiStartY, velX: 0, velY: 0,
                      stuckInCornerTimer: 0, lastPuckPosInCorner: { x: -1, y: -1 },
                      isStuckEscaping: false, escapeAttemptTimer: 0
                  };
             }

             // Створюємо або оновлюємо Шайбу
             if (puck) {
                 puck.x = width / 2; puck.y = height / 2;
                 puck.vx = 0; puck.vy = 0;
                 puck.r = puckRadius; // Оновлюємо радіус
             } else {
                 puck = { x: width / 2, y: height / 2, r: puckRadius, vx: 0, vy: 0, color: puckColor };
             }

             // Подача шайби (залежить від орієнтації)
             let serveSpeed = 5;
             if (isPortrait) {
                 puck.vx = random(-1.0, 1.0) * serveSpeed * 0.3;
                 puck.vy = aiJustScoredOrStuck ? serveSpeed : -serveSpeed; // Вниз, якщо ШІ забив/застряг
             } else { // Landscape
                 puck.vx = aiJustScoredOrStuck ? -serveSpeed : serveSpeed; // Вліво, якщо ШІ забив/застряг
                 puck.vy = random(-1.0, 1.0) * serveSpeed * 0.3;
             }
           //console.log(`Puck served: vx=${puck.vx.toFixed(1)}, vy=${puck.vy.toFixed(1)}`);
        }


        // --- Обробка зміни розміру вікна ---
        function windowResized() {
            let dims = calculateCanvasSize();
            resizeCanvas(dims.w, dims.h);
            resetLayout(); // Повністю скидаємо макет для адаптації
            // Не скидаємо рахунок
        }


// --- Налаштування обробників подій для керування ---
function setupEventListeners() {
            // Складність
            const difficultySelect = document.getElementById('difficulty');
            difficultySelect.addEventListener('change', (event) => {
                difficulty = event.target.value;
              //console.log("Difficulty changed to:", difficulty);
                resetRound(false); // Скидаємо раунд, щоб ШІ грав по-новому
            });
            difficulty = difficultySelect.value;

            // Швидкість ШІ
            const speedSlider = document.getElementById('aiSpeed');
            const speedValueSpan = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (event) => { aiGlobalSpeedMultiplier = parseFloat(event.target.value); speedValueSpan.textContent = aiGlobalSpeedMultiplier.toFixed(1); });
            aiGlobalSpeedMultiplier = parseFloat(speedSlider.value); speedValueSpan.textContent = aiGlobalSpeedMultiplier.toFixed(1);

            // Швидкість Шайби
            const puckSpeedSlider = document.getElementById('puckSpeedSlider');
            const puckSpeedValueSpan = document.getElementById('puckSpeedValue');
            puckSpeedSlider.addEventListener('input', (event) => { currentMaxPuckSpeed = parseFloat(event.target.value); puckSpeedValueSpan.textContent = currentMaxPuckSpeed.toFixed(0); });
            currentMaxPuckSpeed = parseFloat(puckSpeedSlider.value); puckSpeedValueSpan.textContent = currentMaxPuckSpeed.toFixed(0);

            // Зачеплення
             const gripSlider = document.getElementById('gripSlider');
            const gripValueSpan = document.getElementById('gripValue');
            gripSlider.addEventListener('input', (event) => { currentEdgeBlendFactor = parseFloat(event.target.value); gripValueSpan.textContent = currentEdgeBlendFactor.toFixed(2); });
            currentEdgeBlendFactor = parseFloat(gripSlider.value); gripValueSpan.textContent = currentEdgeBlendFactor.toFixed(2);

             // --- ОБРОБНИК ДЛЯ НОВОГО СЛАЙДЕРА ВІДСКОКУ ---
             const bounceSlider = document.getElementById('bounceSlider');
             const bounceValueSpan = document.getElementById('bounceValue');
             bounceSlider.addEventListener('input', (event) => {
                 currentPaddleRestitution = parseFloat(event.target.value);
                 bounceValueSpan.textContent = currentPaddleRestitution.toFixed(2);
               //console.log("Paddle Restitution set to:", currentPaddleRestitution); // Для дебагу
             });
             // Встановлюємо початкове значення при завантаженні
             currentPaddleRestitution = parseFloat(bounceSlider.value);
             bounceValueSpan.textContent = currentPaddleRestitution.toFixed(2);
             // --- Кінець обробника ---

            // Touch events
            canvasElement.elt.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvasElement.elt.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvasElement.elt.addEventListener('touchend', handleTouchEnd);
            canvasElement.elt.addEventListener('touchcancel', handleTouchEnd);

            // Mouse events
            canvasElement.mousePressed(handleMousePressed);
            canvasElement.mouseMoved(handleMouseMoved); // Правильний обробник
            canvasElement.mouseReleased(handleMouseReleased);
        }


        // --- Функції для керування видимістю панелі керування ---
        function showControls() {
            if (!controlsElement) {
                controlsElement = document.querySelector('.controls');
                if (!controlsElement) return;
            }
            // console.log("Showing controls and starting timer.");
            controlsElement.classList.remove('hidden');
            clearTimeout(controlsHideTimeout);
            controlsHideTimeout = setTimeout(hideControls, CONTROLS_HIDE_DELAY);
        }

        function hideControls() {
            if (!controlsElement) {
                controlsElement = document.querySelector('.controls');
                 if (!controlsElement) return;
            }
            // console.log("Hiding controls.");
            controlsElement.classList.add('hidden');
        }

        function handleInteractionForControls() {
            // console.log("Interaction detected, showing controls.");
            showControls(); // Просто показуємо панель (таймер перезапуститься)
        }

        // --- Обробники дотиків/миші ---
        function handleTouchStart(event) {
            handleInteractionForControls(); // Показати панель при дотику
            if (event.touches.length > 0) {
                let touch = event.touches[0];
                let rect = canvasElement.elt.getBoundingClientRect();
                let x = touch.clientX - rect.left;
                let y = touch.clientY - rect.top;
                checkPaddleGrab(x, y);
            }
        }
        function handleTouchMove(event) {
            if (isDragging && event.touches.length > 0) {
                event.preventDefault(); // Запобігаємо прокрутці сторінки
                let touch = event.touches[0];
                let rect = canvasElement.elt.getBoundingClientRect();
                let x = touch.clientX - rect.left;
                let y = touch.clientY - rect.top;
                updatePlayerPosition(x, y);
            }
        }
        function handleTouchEnd(event) { if (isDragging) { releasePaddleGrab(); } }
        function handleMousePressed() {
            handleInteractionForControls(); // Показати панель при кліку
            checkPaddleGrab(mouseX, mouseY);
        }
        function handleMouseDragged() { /* Не використовується, замінено на mouseMoved */ }
        function handleMouseMoved() { if (isDragging) { updatePlayerPosition(mouseX, mouseY); } }
        function handleMouseReleased() { if (isDragging) { releasePaddleGrab(); } }
        function checkPaddleGrab(x, y) { if (!player) return; let d = dist(x, y, player.x, player.y); if (d < player.r * 1.8) { isDragging = true; canvasElement.addClass('grabbing'); } }
        function releasePaddleGrab() { isDragging = false; canvasElement.removeClass('grabbing'); }
        function updatePlayerPosition(newX, newY) {
            if (!player) return;
            player.prevX = player.x; player.prevY = player.y;
            let limitY1, limitY2, limitX1, limitX2;
            // Обмеження руху ЗАЛЕЖНО від орієнтації
            if (isPortrait) { // Гравець знизу
                limitX1 = player.r;
                limitX2 = width - player.r;
                limitY1 = height / 2 + player.r; // Не перетинає центральну лінію
                limitY2 = height - player.r;
            } else { // Гравець зліва
                limitX1 = player.r;
                limitX2 = width / 2 - player.r; // Не перетинає центральну лінію
                limitY1 = player.r;
                limitY2 = height - player.r;
            }
            player.x = constrain(newX, limitX1, limitX2);
            player.y = constrain(newY, limitY1, limitY2);
        }

        // --- Основний цикл малювання p5.js ---
        function draw() {
            // 1. Оновлення логіки
            if (!goalFlash.active) {
                 updatePlayerVelocity();
                 updateAI();
                 if (puck) { updatePuck(); checkCollisions(); checkGoal(); }
            } else {
                goalFlash.timer++;
                if (goalFlash.timer >= GOAL_FLASH_DURATION) {
                    goalFlash.active = false;
                    resetRound(goalFlash.side === 'ai');
                }
            }
            updateTrail();
            updateSparks();

            // 2. Малювання
            background(fieldColor[0], fieldColor[1], fieldColor[2]);
            drawFieldTexture();
            drawField();
            drawBackgroundScore();
            if (puck) drawTrail();
            if (player && ai && puck) {
                drawPaddles();
                drawPuck();
            }
            drawSparks();
        }

        // --- Оновлення швидкості ключки гравця ---
        function updatePlayerVelocity() { if (!player) return; if (!isDragging) { player.velX *= 0.8; player.velY *= 0.8; if (abs(player.velX) < 0.1) player.velX = 0; if (abs(player.velY) < 0.1) player.velY = 0; } else { player.velX = (player.x - player.prevX) * 0.8; player.velY = (player.y - player.prevY) * 0.8; } }

        // --- Оновлення сліду шайби ---
        function updateTrail() {
            if (!puck) return;
            puckTrail.push({ x: puck.x, y: puck.y });
            if (puckTrail.length > TRAIL_LENGTH) {
                puckTrail.shift();
            }
        }

        // --- Оновлення іскор ---
        function updateSparks() {
            for (let i = hitSparks.length - 1; i >= 0; i--) {
                let spark = hitSparks[i];
                spark.x += spark.vx;
                spark.y += spark.vy;
                spark.life--;
                if (spark.life <= 0) {
                    hitSparks.splice(i, 1);
                }
            }
        }

        // --- Створення іскор ---
        function createSparks(x, y, impactAngle) {
            for (let i = 0; i < NUM_SPARKS; i++) {
                let angle = impactAngle + random(-PI / 3, PI / 3);
                let speed = random(2, 5);
                hitSparks.push({
                    x: x, y: y,
                    vx: cos(angle) * speed, vy: sin(angle) * speed,
                    life: floor(random(SPARK_LIFETIME * 0.5, SPARK_LIFETIME)),
                    size: random(1.5, 3.5)
                });
            }
        }


        // ==========================================================
        // ===== ОНОВЛЕНА ЛОГІКА ШІ v17 (Зміни для "Важкої") ====
        // ==========================================================
        function updateAI() {
            if (!ai || !puck) return;

            ai.prevX = ai.x; ai.prevY = ai.y;

            let baseSpeedFactor;
            switch (difficulty) {
                case 'easy': baseSpeedFactor = 0.07; break;
                case 'hard': baseSpeedFactor = 0.25; break;
                case 'medium': default: baseSpeedFactor = 0.15; break;
            }

             // --- АДАПТАЦІЯ ШВИДКОСТІ ("Важка") ---
             if (difficulty === 'hard') {
                let scoreDiff = aiScore - playerScore;
                if (scoreDiff <= -2) { baseSpeedFactor *= 1.15; }
                else if (scoreDiff >= 2) { baseSpeedFactor *= 0.9; }
             }

            baseSpeedFactor *= aiGlobalSpeedMultiplier * overallSpeedBaseMultiplier;

            let targetX = aiBasePos.x; let targetY = aiBasePos.y;
            let currentSpeedFactor = baseSpeedFactor;
            let avoidanceForce = { x: 0, y: 0 };

            const aiGoalX = isPortrait ? width / 2 : width;
            const aiGoalY = isPortrait ? 0 : height / 2;
            const playerGoalX = isPortrait ? width / 2 : 0;
            const playerGoalY = isPortrait ? height : height / 2;

            const aiDistToPuck = dist(ai.x, ai.y, puck.x, puck.y);
            const puckSpeed = sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
            let predictionTime = map(aiDistToPuck, 0, max(width, height) / 2, AI_PREDICTION_FRAMES_MIN, AI_PREDICTION_FRAMES_MAX);
            predictionTime /= map(puckSpeed, 0, currentMaxPuckSpeed * 0.8, 1, 3.0);
            predictionTime = constrain(predictionTime, 2, AI_PREDICTION_FRAMES_MAX);

            // --- Передбачення ("Важка" - з 1 відскоком) ---
            let predictedPuckX = puck.x + puck.vx * predictionTime;
            let predictedPuckY = puck.y + puck.vy * predictionTime;
            if (difficulty === 'hard') {
                 if (isPortrait) {
                    if (predictedPuckX < puckRadius) { predictedPuckX = puckRadius + (puckRadius - predictedPuckX); }
                    else if (predictedPuckX > width - puckRadius) { predictedPuckX = (width - puckRadius) - (predictedPuckX - (width - puckRadius)); }
                 } else {
                    if (predictedPuckY < puckRadius) { predictedPuckY = puckRadius + (puckRadius - predictedPuckY); }
                    else if (predictedPuckY > height - puckRadius) { predictedPuckY = (height - puckRadius) - (predictedPuckY - (height - puckRadius)); }
                 }
            }
            predictedPuckX = constrain(predictedPuckX, puckRadius, width - puckRadius);
            predictedPuckY = constrain(predictedPuckY, puckRadius, height - puckRadius);

            let isPuckMovingTowardsAIGoal = false;
            if (isPortrait) { isPuckMovingTowardsAIGoal = puck.vy < -0.1; }
            else { isPuckMovingTowardsAIGoal = puck.vx > 0.1; }

            let puckNearGoalLine = false; let puckBehindAI = false;
            const desperationDistance = paddleRadius * 2.5;
            if (isPortrait) {
                puckNearGoalLine = puck.y < desperationDistance; puckBehindAI = puck.y < ai.y;
            } else {
                puckNearGoalLine = puck.x > width - desperationDistance; puckBehindAI = puck.x > ai.x;
            }

            let forcedAction = false;

            // --- ПРІОРИТЕТ 1: ВТЕЧА З КУТА ---
            if (ai.isStuckEscaping) {
                if (difficulty === 'hard') { // Розумна втеча
                  //console.log(`AI State: !!! SMART ESCAPE ATTEMPT !!! Timer: ${ai.escapeAttemptTimer}/${STUCK_ESCAPE_TIMEOUT_FRAMES}`);
                    let escapeTarget = calculateSmartEscapeTarget(ai, puck);
                    targetX = escapeTarget.x; targetY = escapeTarget.y;
                    currentSpeedFactor *= STUCK_ESCAPE_FORCE_MULTIPLIER * reactionSpeedModifier * 1.2;
                } else { // Стандартна втеча
                  //console.log(`AI State: !!! ESCAPE ATTEMPT !!! Timer: ${ai.escapeAttemptTimer}/${STUCK_ESCAPE_TIMEOUT_FRAMES}`);
                    let escapeDirX = width / 2 - ai.x; let escapeDirY = height / 2 - ai.y;
                    let escapeMag = sqrt(escapeDirX*escapeDirX + escapeDirY*escapeDirY);
                    if (escapeMag > 1){ escapeDirX /= escapeMag; escapeDirY /= escapeMag; }
                    targetX = ai.x + escapeDirX * 10; targetY = ai.y + escapeDirY * 10;
                    currentSpeedFactor *= STUCK_ESCAPE_FORCE_MULTIPLIER * reactionSpeedModifier;
                }

                let isStillNearCorner = checkAiNearCorner(ai, cornerCheckRadius * 1.1);
                let isPuckStillSlow = puckSpeed < 0.5;
                if (isStillNearCorner && isPuckStillSlow) {
                    ai.escapeAttemptTimer++;
                    if (ai.escapeAttemptTimer > STUCK_ESCAPE_TIMEOUT_FRAMES) {
                      //console.log("!!! AI STUCK ESCAPE FAILED - RESETTING ROUND !!!");
                        resetRound(true); return;
                    }
                } else {
                  //console.log("AI escape successful or puck moved.");
                    ai.isStuckEscaping = false; ai.escapeAttemptTimer = 0;
                }
                forcedAction = true;
            }
            // --- ПРІОРИТЕТ 2: ВІДЧАЙДУШНИЙ СЕЙВ ---
            else if (puckNearGoalLine && puckBehindAI && isPuckMovingTowardsAIGoal) {
               //console.log("AI State: !!! DESPERATION SAVE !!! (Puck Behind)");
                 targetX = isPortrait ? puck.x : width - ai.r;
                 targetY = isPortrait ? ai.r : puck.y;
                 let goalMin = isPortrait ? (width/2 - goalWidth/2) : (height/2 - goalWidth/2);
                 let goalMax = isPortrait ? (width/2 + goalWidth/2) : (height/2 + goalWidth/2);
                 if(isPortrait) targetX = constrain(targetX, goalMin, goalMax);
                 else targetY = constrain(targetY, goalMin, goalMax);
                 targetX = constrain(targetX, ai.r, width - ai.r);
                 targetY = constrain(targetY, ai.r, height - ai.r);
                 currentSpeedFactor *= 5.0 * reactionSpeedModifier;
                 forcedAction = true;
                 ai.stuckInCornerTimer = 0; ai.escapeAttemptTimer = 0;
            }
            // --- ПРІОРИТЕТ 3: ПІДШТОВХУВАННЯ ПОВІЛЬНОЇ ШАЙБИ ---
            else if (puckSpeed < 0.4) {
                let isOnAiHalf = isPortrait ? (puck.y < height / 2 + paddleRadius) : (puck.x > width / 2 - paddleRadius);
                if (isOnAiHalf) {
                    let isNearEdge = false; const edgeDistance = paddleRadius * 3.0;
                    if (isPortrait) { if (puck.y < height / 2 && (puck.x < edgeDistance || puck.x > width - edgeDistance)) isNearEdge = true; }
                    else { if (puck.x > width / 2 && (puck.y < edgeDistance || puck.y > height - edgeDistance)) isNearEdge = true; }
                    if (isNearEdge) {
                      //console.log("AI State: NUDGING SLOW PUCK (Near Edge)");
                        let pushTargetX = width / 2; let pushTargetY = height / 2;
                        let pushVecX = pushTargetX - puck.x; let pushVecY = pushTargetY - puck.y;
                        let pushMag = sqrt(pushVecX*pushVecX + pushVecY*pushVecY);
                        if (pushMag > 0.1) { pushVecX /= pushMag; pushVecY /= pushMag; }
                        else { pushVecX = isPortrait ? 0 : -1; pushVecY = isPortrait ? 1 : 0; }
                        targetX = puck.x - pushVecX * (ai.r * 0.6);
                        targetY = puck.y - pushVecY * (ai.r * 0.6);
                        currentSpeedFactor *= 1.8 * reactionSpeedModifier;
                        forcedAction = true;
                        ai.stuckInCornerTimer = 0; ai.escapeAttemptTimer = 0;
                    }
                }
            }

            // --- ЗВИЧАЙНА ЛОГІКА ---
            if (!forcedAction) {
                 let criticalCheck = isPortrait ? (predictedPuckY < aiCriticalDefenseLine && isPuckMovingTowardsAIGoal) : (predictedPuckX > aiCriticalDefenseLine && isPuckMovingTowardsAIGoal);
                 let defenseCheck = isPortrait ? (predictedPuckY < aiDefensiveLine && isPuckMovingTowardsAIGoal) : (predictedPuckX > aiDefensiveLine && isPuckMovingTowardsAIGoal);

                // --- КРИТИЧНИЙ ЗАХИСТ ---
                if (criticalCheck) {
                  //console.log("AI State: !!! CRITICAL DEFENSE !!!");
                     let clearTargetX, clearTargetY;
                     if (isPortrait) {
                        clearTargetX = (predictedPuckX < width / 2) ? playerGoalX - width * 0.2 : playerGoalX + width * 0.2;
                        clearTargetY = playerGoalY + height * 0.1;
                     } else {
                        clearTargetX = playerGoalX - width * 0.1;
                        clearTargetY = (predictedPuckY < height / 2) ? playerGoalY - height * 0.2 : playerGoalY + height * 0.2;
                     }
                    // Проактивне уникнення кутів ("Важка")
                    if (difficulty === 'hard' && isNearCorner(predictedPuckX, predictedPuckY, puckRadius * 2)) {
                       //console.log("--- Proactive Corner Avoidance (Critical) ---");
                         clearTargetX = width / 2; clearTargetY = height / 2;
                    }
                     clearTargetX = lerp(predictedPuckX, clearTargetX, AI_CRITICAL_CLEAR_STRENGTH);
                     clearTargetY = lerp(predictedPuckY, clearTargetY, AI_CRITICAL_CLEAR_STRENGTH);
                     let clearVectorX = clearTargetX - predictedPuckX; let clearVectorY = clearTargetY - predictedPuckY;
                     let mag = sqrt(clearVectorX*clearVectorX + clearVectorY*clearVectorY);
                     if (mag > 0.1) { clearVectorX /= mag; clearVectorY /= mag; }
                     else { clearVectorX = isPortrait ? 0 : -1; clearVectorY = isPortrait ? 1 : 0; }
                     targetX = predictedPuckX - clearVectorX * aiOffensivePush * 0.6;
                     targetY = predictedPuckY - clearVectorY * aiOffensivePush * 0.6;
                     currentSpeedFactor *= 4.0 * reactionSpeedModifier;
                     ai.stuckInCornerTimer = 0; ai.escapeAttemptTimer = 0;
                }
                // --- ЗВИЧАЙНИЙ ЗАХИСТ ---
                else if (defenseCheck) {
                   //console.log("AI State: DEFENSE (Intercept & Clear)");
                     let interceptX = predictedPuckX; let interceptY = predictedPuckY;
                     let clearTargetX, clearTargetY;
                    // Розумне позиціонування ("Важка")
                     if (difficulty === 'hard') {
                       //console.log("--- Smart Defense Positioning ---");
                         let goalLineCenterX = isPortrait ? width / 2 : width - ai.r;
                         let goalLineCenterY = isPortrait ? ai.r : height / 2;
                         let vecToGoalX = goalLineCenterX - predictedPuckX; let vecToGoalY = goalLineCenterY - predictedPuckY;
                         let distToGoal = sqrt(vecToGoalX * vecToGoalX + vecToGoalY * vecToGoalY);
                         if (distToGoal > 0.1) { vecToGoalX /= distToGoal; vecToGoalY /= distToGoal; }
                         targetX = predictedPuckX - vecToGoalX * (paddleRadius * 0.8);
                         targetY = predictedPuckY - vecToGoalY * (paddleRadius * 0.8);
                          if (isPortrait) { clearTargetX = lerp(playerGoalX, (predictedPuckX < width / 2 ? 0 : width), AI_DEFENSE_CLEAR_BIAS * 1.5); clearTargetY = playerGoalY; }
                          else { clearTargetX = playerGoalX; clearTargetY = lerp(playerGoalY, (predictedPuckY < height / 2 ? 0 : height), AI_DEFENSE_CLEAR_BIAS * 1.5); }
                     } else { // Стандартна логіка
                         if (isPortrait) { clearTargetX = lerp(playerGoalX, (predictedPuckX < width / 2 ? 0 : width), AI_DEFENSE_CLEAR_BIAS); clearTargetY = playerGoalY; }
                         else { clearTargetX = playerGoalX; clearTargetY = lerp(playerGoalY, (predictedPuckY < height / 2 ? 0 : height), AI_DEFENSE_CLEAR_BIAS); }
                         let clearVectorX = clearTargetX - interceptX; let clearVectorY = clearTargetY - interceptY;
                         let mag = sqrt(clearVectorX * clearVectorX + clearVectorY * clearVectorY);
                         if (mag > 0.1) { clearVectorX /= mag; clearVectorY /= mag; } else { clearVectorX = isPortrait ? 0 : -1; clearVectorY = isPortrait ? 1 : 0; }
                         targetX = interceptX - clearVectorX * aiOffensivePush * 0.8;
                         targetY = interceptY - clearVectorY * aiOffensivePush * 0.8;
                     }
                     // Проактивне уникнення кутів ("Важка")
                    if (difficulty === 'hard' && isNearCorner(targetX, targetY, paddleRadius * 1.5)) {
                       //console.log("--- Proactive Corner Avoidance (Defense) ---");
                         if (isPortrait) { targetY = max(targetY, paddleRadius * 2.5); clearTargetX = (targetX < width/2) ? width : 0; clearTargetY = targetY + height*0.2; }
                         else { targetX = min(targetX, width - paddleRadius * 2.5); clearTargetY = (targetY < height/2) ? height : 0; clearTargetX = targetX - width*0.2; }
                         let clearVectorX = clearTargetX - interceptX; let clearVectorY = clearTargetY - interceptY;
                         let mag = sqrt(clearVectorX * clearVectorX + clearVectorY * clearVectorY);
                         if (mag > 0.1) { clearVectorX /= mag; clearVectorY /= mag; } else { clearVectorX = isPortrait ? 0 : -1; clearVectorY = isPortrait ? 1 : 0; }
                         targetX = interceptX - clearVectorX * aiOffensivePush * 0.8;
                         targetY = interceptY - clearVectorY * aiOffensivePush * 0.8;
                    }
                     currentSpeedFactor *= 2.2 * reactionSpeedModifier;
                     ai.stuckInCornerTimer = 0; ai.escapeAttemptTimer = 0;
                }
                // --- АКТИВНА ГРА / ОЧІКУВАННЯ ---
                else {
                     let isActiveZone = isPortrait ? (predictedPuckY < height / 2 + puck.r * 3) : (predictedPuckX > width / 2 - puck.r * 3);
                     if (isActiveZone) {
                       //console.log("AI State: ACTIVE PLAY (Intercept & Aim)");
                         let aimVecX = playerGoalX - predictedPuckX; let aimVecY = playerGoalY - predictedPuckY;
                         // Банк-шот ("Важка")
                         let useBankShot = false;
                         if (difficulty === 'hard') {
                            let directShotBlocked = isDirectShotBlockedByPlayer(predictedPuckX, predictedPuckY, playerGoalX, playerGoalY, player);
                            if (directShotBlocked) {
                              //console.log("--- Attempting Bank Shot ---");
                                let bankTarget = calculateBankShotTarget(predictedPuckX, predictedPuckY, playerGoalX, playerGoalY);
                                if (bankTarget) { aimVecX = bankTarget.aimVecX; aimVecY = bankTarget.aimVecY; useBankShot = true; console.log("--- Bank Shot Calculated ---"); }
                                else { console.log("--- Bank Shot Failed, using direct ---"); }
                            }
                         }
                         // Пряме прицілювання (якщо не банк-шот)
                         if (!useBankShot) {
                             let aimMag = sqrt(aimVecX*aimVecX + aimVecY*aimVecY);
                             if(aimMag > 0.1){ aimVecX /= aimMag; aimVecY /= aimMag; } else { aimVecX = isPortrait ? 0 : -1; aimVecY = isPortrait ? 1 : 0; }
                             let aimAngle = atan2(aimVecY, aimVecX);
                             let randomAngleOffset = random(-aiAimAssist * (difficulty === 'hard' ? 1.2 : 1.0), aiAimAssist * (difficulty === 'hard' ? 1.2 : 1.0));
                             aimAngle += randomAngleOffset;
                             aimVecX = cos(aimAngle); aimVecY = sin(aimAngle);
                         }
                         targetX = predictedPuckX - aimVecX * aiOffensivePush; targetY = predictedPuckY - aimVecY * aiOffensivePush;
                         let speedBoost = (puckSpeed > 1.0) ? map(puckSpeed, 1, currentMaxPuckSpeed, 1.3, 2.0) : 1.3;
                         currentSpeedFactor *= speedBoost * reactionSpeedModifier;
                         ai.stuckInCornerTimer = 0; ai.escapeAttemptTimer = 0;
                     } else { // Очікування
                          //console.log("AI State: WAITING / Returning");
                          targetX = aiBasePos.x; targetY = aiBasePos.y;
                          currentSpeedFactor *= 0.7 * reactionSpeedModifier;
                          // Перевірка початкового застрягання
                          let isNearCornerCheck = checkAiNearCorner(ai, cornerCheckRadius * 1.1);
                          if (isNearCornerCheck && aiDistToPuck < (ai.r + puck.r + paddleRadius * 0.5) ) {
                             if (puckSpeed < 0.3 && ai.lastPuckPosInCorner.x > 0) {
                                 ai.stuckInCornerTimer++;
                                 //console.log(`Initial Stuck Timer: ${ai.stuckInCornerTimer}/${STUCK_INITIAL_THRESHOLD_FRAMES}`);
                                 if (ai.stuckInCornerTimer > STUCK_INITIAL_THRESHOLD_FRAMES) {
                                    // console.log("!!! TRIGGERING ESCAPE ATTEMPT !!!");
                                     ai.isStuckEscaping = true; ai.stuckInCornerTimer = 0; ai.escapeAttemptTimer = 0;
                                 }
                             } else { ai.stuckInCornerTimer = 0; ai.lastPuckPosInCorner = { x: puck.x, y: puck.y }; }
                          } else { ai.stuckInCornerTimer = 0; ai.lastPuckPosInCorner = { x: -1, y: -1 }; }
                     }
                }
            }

            // --- УНИКНЕННЯ СТІН ---
            avoidanceForce = calculateWallAvoidance(ai, isPortrait, scaledWallAvoidDistance, wallAvoidanceForce, aiGoalX, aiGoalY);

            // --- ЗАСТОСУВАННЯ РУХУ ---
            let desiredVelX = (targetX - ai.x) * currentSpeedFactor; let desiredVelY = (targetY - ai.y) * currentSpeedFactor;
            desiredVelX += avoidanceForce.x * currentSpeedFactor * 55; desiredVelY += avoidanceForce.y * currentSpeedFactor * 55;
            let desiredSpeed = sqrt(desiredVelX * desiredVelX + desiredVelY * desiredVelY);
            let maxAllowedSpeed = baseSpeedFactor * (difficulty === 'hard' ? 200 : 180) * reactionSpeedModifier;
            if (desiredSpeed > maxAllowedSpeed) { desiredVelX = (desiredVelX / desiredSpeed) * maxAllowedSpeed; desiredVelY = (desiredVelY / desiredSpeed) * maxAllowedSpeed; }
            // Обмеження швидкості при сейві
            if (!ai.isStuckEscaping && puckNearGoalLine && puckBehindAI && isPuckMovingTowardsAIGoal) {
                 const desperationMaxSpeed = currentMaxPuckSpeed * 0.8 * reactionSpeedModifier;
                 let currentDesiredSpeed = sqrt(desiredVelX * desiredVelX + desiredVelY * desiredVelY);
                 if (currentDesiredSpeed > desperationMaxSpeed) { desiredVelX = (desiredVelX / currentDesiredSpeed) * desperationMaxSpeed; desiredVelY = (desiredVelY / currentDesiredSpeed) * desperationMaxSpeed; }
            }
            ai.x += desiredVelX; ai.y += desiredVelY;

            // --- ОБМЕЖЕННЯ ПОЗИЦІЇ ШІ ---
            const borderMargin = 0.5;
            let constrainedX = ai.x; let constrainedY = ai.y;
            if(isPortrait){ // Верхня половина
                constrainedX = constrain(ai.x, ai.r + borderMargin, width - ai.r - borderMargin);
                constrainedY = constrain(ai.y, ai.r + borderMargin, height / 2 - ai.r - borderMargin);
            } else { // Права половина
                constrainedX = constrain(ai.x, width / 2 + ai.r + borderMargin, width - ai.r - borderMargin);
                constrainedY = constrain(ai.y, ai.r + borderMargin, height - ai.r - borderMargin);
            }
            ai.x = constrainedX; ai.y = constrainedY;

            ai.velX = ai.x - ai.prevX; ai.velY = ai.y - ai.prevY;
        }
        // ===== Кінець updateAI =====


        // --- Допоміжні функції для ШІ "Важка" ---
        function checkAiNearCorner(agent, checkDist) { if (!agent) return false; if(isPortrait){ return (agent.y < checkDist + agent.r) && (agent.x < checkDist + agent.r || agent.x > width - checkDist - agent.r); } else{ return (agent.x > width - checkDist - agent.r) && (agent.y < checkDist + agent.r || agent.y > height - checkDist - agent.r); } }
        function isNearCorner(x, y, threshold) { let nearTop = y < threshold; let nearBottom = y > height - threshold; let nearLeft = x < threshold; let nearRight = x > width - threshold; return (nearTop && nearLeft) || (nearTop && nearRight) || (nearBottom && nearLeft) || (nearBottom && nearRight); }
        function calculateSmartEscapeTarget(agent, puck) {
            let target = { x: width / 2, y: height / 2 };
            let escapeDist = agent.r * 2.5;
             let nearTop = agent.y < agent.r + 10; let nearLeft = agent.x < agent.r + 10; let nearRight = agent.x > width - agent.r - 10;
             let nearGoalLine = isPortrait ? nearTop : (agent.x > width - agent.r - 10);
             let nearSideWallLeft = isPortrait ? nearLeft : (agent.y < agent.r + 10);
             let nearSideWallRight = isPortrait ? nearRight : (agent.y > height - agent.r - 10);
            if (nearGoalLine && nearSideWallLeft) { target.x = agent.x + escapeDist; target.y = agent.y + escapeDist; }
            else if (nearGoalLine && nearSideWallRight) { target.x = agent.x - escapeDist; target.y = agent.y + escapeDist; }
            else if (nearGoalLine) { target.x = agent.x; target.y = agent.y + escapeDist * 1.5; }
            else if (nearSideWallLeft) { target.x = agent.x + escapeDist * 1.5; target.y = agent.y; }
            else if (nearSideWallRight) { target.x = agent.x - escapeDist * 1.5; target.y = agent.y; }
             target.x = constrain(target.x, agent.r, width - agent.r); target.y = constrain(target.y, agent.r, height - agent.r);
             return target;
        }
        function isDirectShotBlockedByPlayer(puckX, puckY, goalX, goalY, playerPaddle) {
            if (!playerPaddle) return false;
            let lineDist = distPointLine(playerPaddle.x, playerPaddle.y, puckX, puckY, goalX, goalY);
            let dotProductCheck = (playerPaddle.x - puckX) * (goalX - puckX) + (playerPaddle.y - puckY) * (goalY - puckY);
            let isBetween = dotProductCheck > 0 && dotProductCheck < distSq(puckX, puckY, goalX, goalY);
            return lineDist < (playerPaddle.r * 2.0) && isBetween;
        }
        function distPointLine(px, py, x1, y1, x2, y2) { let L2 = distSq(x1, y1, x2, y2); if (L2 === 0) return dist(px, py, x1, y1); let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2; t = max(0, min(1, t)); let projX = x1 + t * (x2 - x1); let projY = y1 + t * (y2 - y1); return dist(px, py, projX, projY); }
        function distSq(x1, y1, x2, y2){ return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2); }
        function calculateBankShotTarget(puckX, puckY, goalX, goalY) {
             let targetWallY, targetWallX; let wallNormalX, wallNormalY;
             let bestBankTarget = null; let minAngleDiff = PI;
            for (let side of [-1, 1]) {
                 if (isPortrait) { targetWallY = (side === -1) ? puckRadius : height - puckRadius; let intersectX = lerp(puckX, goalX, 0.5); intersectX = constrain(intersectX, puckRadius, width-puckRadius); wallNormalX = 0; wallNormalY = -side; targetWallX = intersectX; }
                 else { targetWallX = (side === -1) ? puckRadius : width - puckRadius; let intersectY = lerp(puckY, goalY, 0.5); intersectY = constrain(intersectY, puckRadius, height-puckRadius); wallNormalX = -side; wallNormalY = 0; targetWallY = intersectY; }
                 let vecToWallX = targetWallX - puckX; let vecToWallY = targetWallY - puckY; let distToWall = sqrt(vecToWallX * vecToWallX + vecToWallY * vecToWallY); if (distToWall < 1) continue; vecToWallX /= distToWall; vecToWallY /= distToWall;
                 let vecWallToGoalX = goalX - targetWallX; let vecWallToGoalY = goalY - targetWallY; let distWallToGoal = sqrt(vecWallToGoalX * vecWallToGoalX + vecWallToGoalY * vecWallToGoalY); if (distWallToGoal < 1) continue; vecWallToGoalX /= distWallToGoal; vecWallToGoalY /= distWallToGoal;
                 let dotIncoming = vecToWallX * wallNormalX + vecToWallY * wallNormalY; let dotOutgoing = vecWallToGoalX * wallNormalX + vecWallToGoalY * wallNormalY;
                 let angleDiff = abs(acos(constrain(dotIncoming, -1, 1)) + acos(constrain(dotOutgoing, -1, 1)) - PI);
                 if (angleDiff < 0.8 && angleDiff < minAngleDiff) { minAngleDiff = angleDiff; bestBankTarget = { aimVecX: vecToWallX, aimVecY: vecToWallY }; }
            } return bestBankTarget;
        }

        // --- Розрахунок сили уникнення стін ---
        function calculateWallAvoidance(agent, isPortraitOrientation, avoidDistance, forceMagnitude, goalX, goalY) { let totalForce = { x: 0, y: 0 }; let steer; const goalAvoidBoost = 1.6; if (isPortraitOrientation) { let distToGoalLine = agent.y; let boost = (distToGoalLine < avoidDistance * 1.5) ? goalAvoidBoost : 1.0; steer = calculateSingleWallAvoidance(agent.y, 0, avoidDistance * boost, forceMagnitude * boost); if (steer !== 0) totalForce.y += steer; steer = calculateSingleWallAvoidance(agent.x, 0, avoidDistance, forceMagnitude); if (steer !== 0) totalForce.x += steer; steer = calculateSingleWallAvoidance(agent.x, width, avoidDistance, forceMagnitude); if (steer !== 0) totalForce.x += steer; steer = calculateSingleWallAvoidance(agent.y, height / 2, avoidDistance * 0.5, forceMagnitude * 0.4); if (steer !== 0) totalForce.y += steer; } else { let distToGoalLine = width - agent.x; let boost = (distToGoalLine < avoidDistance * 1.5) ? goalAvoidBoost : 1.0; steer = calculateSingleWallAvoidance(agent.x, width, avoidDistance * boost, forceMagnitude * boost); if (steer !== 0) totalForce.x += steer; steer = calculateSingleWallAvoidance(agent.y, 0, avoidDistance, forceMagnitude); if (steer !== 0) totalForce.y += steer; steer = calculateSingleWallAvoidance(agent.y, height, avoidDistance, forceMagnitude); if (steer !== 0) totalForce.y += steer; steer = calculateSingleWallAvoidance(agent.x, width / 2, avoidDistance * 0.5, forceMagnitude * 0.4); if (steer !== 0) totalForce.x += steer; } return totalForce; }
        function calculateSingleWallAvoidance(agentPos, wallPos, avoidDist, forceMag) { let diff = agentPos - wallPos; let distToWall = abs(diff); if (distToWall < avoidDist && distToWall > 0.01) { let repelForce = pow((avoidDist - distToWall) / avoidDist, 1.8); let direction = (diff > 0 ? 1 : -1); return direction * repelForce * forceMag; } return 0; }

        // --- Оновлення фізики шайби ---
        function updatePuck() {
             if (!puck) return;
             puck.x += puck.vx; puck.y += puck.vy;
             puck.vx *= friction; puck.vy *= friction;
             let speed = sqrt(puck.vx*puck.vx + puck.vy*puck.vy);
             if (speed > currentMaxPuckSpeed) { puck.vx = (puck.vx / speed) * currentMaxPuckSpeed; puck.vy = (puck.vy / speed) * currentMaxPuckSpeed; }
             if (speed < 0.1 && !isDragging) { puck.vx = 0; puck.vy = 0; }

             let goalPos, goalSize; let slightlyMoreFrictionOnWalls = 0.95;
             if (isPortrait) {
                 goalPos = width / 2; goalSize = goalWidth; let goalLimitLeft = goalPos - goalSize / 2; let goalLimitRight = goalPos + goalSize / 2;
                 if ((puck.y - puck.r < 0 && !(puck.x > goalLimitLeft && puck.x < goalLimitRight)) || (puck.y + puck.r > height && !(puck.x > goalLimitLeft && puck.x < goalLimitRight))) {
                     puck.vy *= wallRestitution; puck.y = constrain(puck.y, puck.r, height - puck.r); puck.vx *= slightlyMoreFrictionOnWalls;
                 }
                  if (puck.x - puck.r < 0 || puck.x + puck.r > width) {
                     puck.vx *= wallRestitution; puck.x = constrain(puck.x, puck.r, width - puck.r); puck.vy *= slightlyMoreFrictionOnWalls;
                 }
             } else { // Landscape
                 goalPos = height / 2; goalSize = goalWidth; let goalLimitTop = goalPos - goalSize / 2; let goalLimitBottom = goalPos + goalSize / 2;
                 if ((puck.x - puck.r < 0 && !(puck.y > goalLimitTop && puck.y < goalLimitBottom)) || (puck.x + puck.r > width && !(puck.y > goalLimitTop && puck.y < goalLimitBottom))) {
                     puck.vx *= wallRestitution; puck.x = constrain(puck.x, puck.r, width - puck.r); puck.vy *= slightlyMoreFrictionOnWalls;
                 }
                  if (puck.y - puck.r < 0 || puck.y + puck.r > height) {
                     puck.vy *= wallRestitution; puck.y = constrain(puck.y, puck.r, height - puck.r); puck.vx *= slightlyMoreFrictionOnWalls;
                 }
             }
             puck.x = constrain(puck.x, -puck.r * 5, width + puck.r * 5); puck.y = constrain(puck.y, -puck.r * 5, height + puck.r * 5);
        }

        // --- Перевірка зіткнень ---
        function checkCollisions() { if (!player || !ai || !puck) return; handlePaddleCollision(player); handlePaddleCollision(ai); }


        // --- Обробка зіткнення ключки з шайбою ---
        function handlePaddleCollision(paddle) {
            if (!paddle || !puck) return; // Додаткова перевірка на існування об'єктів
            let dx = puck.x - paddle.x;
            let dy = puck.y - paddle.y;
            let distance = sqrt(dx * dx + dy * dy);
            let minDistance = puck.r + paddle.r;

            // Перевірка, чи відбулося зіткнення (дистанція менша за суму радіусів)
            // і чи не знаходяться вони точно в одній точці (distance > 0.1)
            if (distance < minDistance && distance > 0.1) {

                // Нормаль зіткнення (вектор від центру ключки до центру шайби)
                let normalX = dx / distance;
                let normalY = dy / distance;

                // Відносна швидкість шайби відносно ключки
                let relativeVelX = puck.vx - paddle.velX;
                let relativeVelY = puck.vy - paddle.velY;

                // Проекція відносної швидкості на нормаль зіткнення
                let velocityAlongNormal = relativeVelX * normalX + relativeVelY * normalY;

                // Якщо швидкість вздовж нормалі позитивна, об'єкти вже розходяться
                // (або шайба "проникла" глибоко і рухається на вихід).
                // Ми не застосовуємо імпульс у цьому випадку, щоб уникнути "прилипання".
                // Але ми все одно можемо виштовхнути шайбу, якщо вона перекривається.
                if (velocityAlongNormal > 0) {
                    let overlap = minDistance - distance;
                    // Виштовхуємо шайбу, якщо є значне перекриття, щоб запобігти застряганню
                    if (overlap > 0.1) {
                        puck.x += normalX * (overlap + 0.1); // Невеликий додатковий поштовх
                        puck.y += normalY * (overlap + 0.1);
                    }
                    return; // Вихід, не застосовуємо імпульс
                }

                // --- ВИКОРИСТАННЯ ЗМІННОГО ВІДСКОКУ ---
                // Використовуємо поточне значення зі слайдера для основного відскоку
                let restitution = currentPaddleRestitution;
                // --------------------------------------

                // Розрахунок величини імпульсу за формулою пружного зіткнення
                // -(1 + коефіцієнт відновлення) * швидкість вздовж нормалі
                // Чим більший restitution, тим сильніший відскок
                let impulseMagnitude = -(1.0 + restitution) * velocityAlongNormal;

                // Додаємо базову мінімальну силу удару, щоб навіть легкі дотики мали ефект
                const baseHitForce = 2.5;
                impulseMagnitude = max(impulseMagnitude, baseHitForce);

                // Додаємо силу, що залежить від швидкості самої ключки
                let paddleVelMag = sqrt(paddle.velX * paddle.velX + paddle.velY * paddle.velY);
                let paddleSpeedFactor = constrain(paddleVelMag * 0.15, 0, 6); // Масштабуємо і обмежуємо
                impulseMagnitude += paddleSpeedFactor;

                // Початково напрямок імпульсу - вздовж нормалі
                let impulseDirX = normalX;
                let impulseDirY = normalY;

                // --- Обробка удару краєм (Зачеплення) ---
                // Якщо відстань більша за певний поріг (тобто удар ближче до краю ключки)
                // і слайдер "Зачеплення" встановлений на значення > 0
                const edgeHitThreshold = paddle.r * 0.7;
                if (distance > edgeHitThreshold && currentEdgeBlendFactor > 0.01) {
                     // console.log("Edge Hit Detected!");

                     // --- ВІДСКОК КРАЄМ ЗАЛЕЖИТЬ ВІД ОСНОВНОГО ---
                     // Робимо відскок краєм менш пружним, ніж центральний,
                     // але залежним від налаштування основного відскоку.
                     // Забезпечуємо мінімальне значення, щоб шайба не "в'язла".
                     restitution = max(0.3, currentPaddleRestitution - 0.2); // Наприклад, на 0.2 менше, але не нижче 0.3
                     // ------------------------------------------

                     // Перераховуємо імпульс з новим (зменшеним) коефіцієнтом відновлення
                     impulseMagnitude = -(1.0 + restitution) * velocityAlongNormal;
                     // Застосовуємо трохи меншу базову силу для удару краєм
                     impulseMagnitude = max(impulseMagnitude, baseHitForce * 0.8);
                     // Додаємо швидкість ключки знову, оскільки імпульс перераховано
                     impulseMagnitude += paddleSpeedFactor;

                     // Розраховуємо вектор дотичної до точки зіткнення
                     let tangentX = -normalY;
                     let tangentY = normalX;

                     // Змішуємо напрямок нормалі та дотичної за допомогою lerp
                     // Фактор змішування береться зі слайдера "Зачеплення"
                     impulseDirX = lerp(normalX, tangentX, currentEdgeBlendFactor);
                     impulseDirY = lerp(normalY, tangentY, currentEdgeBlendFactor);

                     // Нормалізуємо отриманий вектор напрямку імпульсу
                     let impulseDirMag = sqrt(impulseDirX * impulseDirX + impulseDirY * impulseDirY);
                     if (impulseDirMag > 0.01) { // Перевірка ділення на нуль
                        impulseDirX /= impulseDirMag;
                        impulseDirY /= impulseDirMag;
                     }
                }

                // Застосування імпульсу до швидкості шайби
                puck.vx += impulseMagnitude * impulseDirX;
                puck.vy += impulseMagnitude * impulseDirY;

                // Обмеження максимальної швидкості шайби після удару
                let currentSpeed = sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
                if (currentSpeed > currentMaxPuckSpeed) {
                    puck.vx = (puck.vx / currentSpeed) * currentMaxPuckSpeed;
                    puck.vy = (puck.vy / currentSpeed) * currentMaxPuckSpeed;
                }

                // --- Корекція позиції для уникнення застрягання ("розштовхування") ---
                // Розраховуємо величину перекриття об'єктів
                 let overlap = minDistance - distance;
                 let pushFactor = 1.05; // Невеликий коефіцієнт для сильнішого розштовхування
                 // Якщо є перекриття, виштовхуємо шайбу вздовж нормалі
                 if (overlap > 0) {
                     puck.x += normalX * (overlap * pushFactor + 0.1);
                     puck.y += normalY * (overlap * pushFactor + 0.1);

                     // Додаткова перевірка: якщо після виштовхування вони все ще перекриваються
                     // (може статися при дуже великих швидкостях/малих кроках часу),
                     // то примусово встановлюємо шайбу на межу ключки.
                     let dx_after = puck.x - paddle.x;
                     let dy_after = puck.y - paddle.y;
                     let dist_after = sqrt(dx_after*dx_after + dy_after*dy_after);
                     if (dist_after < minDistance) {
                         puck.x = paddle.x + normalX * (minDistance + 0.05); // Ставимо трохи зовні
                         puck.y = paddle.y + normalY * (minDistance + 0.05);
                     }
                 }

                // Створення візуального ефекту іскор при ударі
                // Розраховуємо кут, з якого прийшов удар (протилежний імпульсу)
                let impactAngle = atan2(impulseDirY, impulseDirX);
                // Створюємо іскри в точці контакту (приблизно), що летять назад
                createSparks(puck.x - normalX * puck.r, puck.y - normalY * puck.r, impactAngle + PI);
            }
        }


        // --- Перевірка голу ---
        function checkGoal() {
            if (!puck || goalFlash.active) return;
            let goalScored = false; let aiScored = false;
            let goalCenter, goalSize;
            if (isPortrait) {
                goalCenter = width / 2; goalSize = goalWidth; let goalLimitLeft = goalCenter - goalSize / 2; let goalLimitRight = goalCenter + goalSize / 2;
                if (puck.y - puck.r < -puck.r * 0.5 && puck.x > goalLimitLeft && puck.x < goalLimitRight) { playerScore++; console.log("Player scores!"); goalScored = true; aiScored = false; startGoalAnimation('player'); }
                if (puck.y + puck.r > height + puck.r*0.5 && puck.x > goalLimitLeft && puck.x < goalLimitRight) { aiScore++; console.log("AI scores!"); goalScored = true; aiScored = true; startGoalAnimation('ai'); }
            } else { // Landscape
                goalCenter = height / 2; goalSize = goalWidth; let goalLimitTop = goalCenter - goalSize / 2; let goalLimitBottom = goalCenter + goalSize / 2;
                 if (puck.x - puck.r < -puck.r*0.5 && puck.y > goalLimitTop && puck.y < goalLimitBottom) { aiScore++; console.log("AI scores!"); goalScored = true; aiScored = true; startGoalAnimation('ai'); }
                 if (puck.x + puck.r > width + puck.r*0.5 && puck.y > goalLimitTop && puck.y < goalLimitBottom) { playerScore++; console.log("Player scores!"); goalScored = true; aiScored = false; startGoalAnimation('player'); }
            }
            // Скидання раунду перенесено в draw() після анімації
        }

        // --- Запуск анімації спалаху воріт ---
        function startGoalAnimation(whoScored) {
             goalFlash.side = (whoScored === 'player') ? 'ai' : 'player';
             goalFlash.active = true; goalFlash.timer = 0;
             if (puck) { puck.vx = 0; puck.vy = 0; }
        }

        // --- Малювання текстури поля ---
        function drawFieldTexture() {
            push(); strokeWeight(0.4);
            for (let i = 0; i < 150; i++) {
                 let x1 = random(width); let y1 = random(height);
                 let noiseVal = noise(x1 * 0.01, y1 * 0.01, frameCount * 0.0005); // Додамо трохи анімації шуму
                 let angle = noiseVal * TWO_PI * 2; let len = noiseVal * 15 + 5;
                 let x2 = x1 + cos(angle) * len; let y2 = y1 + sin(angle) * len;
                 let alpha = map(noiseVal, 0, 1, 5, 20);
                 stroke(200, 200, 220, alpha); line(x1, y1, x2, y2);
             } pop();
        }

        // --- Малювання поля (з анімацією воріт) ---
        function drawField() {
            stroke(200, 200, 200, 100); strokeWeight(max(1.5, min(width,height)*0.005));
            if (isPortrait) { line(0, height / 2, width, height / 2); }
            else { line(width / 2, 0, width / 2, height); }
            noFill(); ellipse(width / 2, height / 2, min(width,height)*0.18, min(width,height)*0.18);
            let goalCenter, goalSize, gY1, gY2, gX1, gX2;
            let baseGoalWeight = max(3, min(width,height)*0.01);
            let flashGoalWeight = max(5, min(width,height)*0.015);
            if (isPortrait) {
                goalCenter = width / 2; goalSize = goalWidth; gX1 = goalCenter - goalSize / 2; gX2 = goalCenter + goalSize / 2;
                // Ворота гравця (знизу)
                let playerGoalFlashing = goalFlash.active && goalFlash.side === 'player';
                strokeWeight(playerGoalFlashing ? flashGoalWeight : baseGoalWeight);
                stroke(playerColor[0], playerColor[1], playerColor[2], playerGoalFlashing ? 255 : 200);
                line(gX1, height, gX2, height);
                // Ворота ШІ (зверху)
                let aiGoalFlashing = goalFlash.active && goalFlash.side === 'ai';
                strokeWeight(aiGoalFlashing ? flashGoalWeight : baseGoalWeight);
                stroke(aiColor[0], aiColor[1], aiColor[2], aiGoalFlashing ? 255 : 200);
                line(gX1, 0, gX2, 0);
            } else { // Landscape
                goalCenter = height / 2; goalSize = goalWidth; gY1 = goalCenter - goalSize / 2; gY2 = goalCenter + goalSize / 2;
                // Ворота гравця (зліва)
                let playerGoalFlashing = goalFlash.active && goalFlash.side === 'player';
                strokeWeight(playerGoalFlashing ? flashGoalWeight : baseGoalWeight);
                stroke(playerColor[0], playerColor[1], playerColor[2], playerGoalFlashing ? 255 : 200);
                line(0, gY1, 0, gY2);
                // Ворота ШІ (справа)
                let aiGoalFlashing = goalFlash.active && goalFlash.side === 'ai';
                strokeWeight(aiGoalFlashing ? flashGoalWeight : baseGoalWeight);
                stroke(aiColor[0], aiColor[1], aiColor[2], aiGoalFlashing ? 255 : 200);
                line(width, gY1, width, gY2);
            }
            noStroke(); fill(255);
        }

        // --- Малювання рахунку ---
        function drawBackgroundScore() {
            fill(scoreColor[0], scoreColor[1], scoreColor[2], scoreColor[3]);
            let scoreTextSize;
            if (isPortrait) { scoreTextSize = width * 0.35; } else { scoreTextSize = min(width, height) * 0.22; }
            textSize(scoreTextSize);
            strokeWeight(max(1, scoreTextSize * 0.04));
            stroke(fieldColor[0] * 0.3, fieldColor[1] * 0.3, fieldColor[2] * 0.4, 150);
            text(`${playerScore} - ${aiScore}`, width / 2, height / 2);
            noStroke();
        }


        // --- Малювання ключок з тінями та дизайном ---
        function drawPaddles() {
            if (!player || !ai) return;
            drawingContext.shadowBlur = 15; drawingContext.shadowColor = 'rgba(0, 0, 0, 0.4)';
            drawingContext.shadowOffsetX = 3; drawingContext.shadowOffsetY = 5;
            fill(player.color[0], player.color[1], player.color[2]); ellipse(player.x, player.y, player.r * 2);
            fill(ai.color[0], ai.color[1], ai.color[2]); ellipse(ai.x, ai.y, ai.r * 2);
             drawingContext.shadowBlur = 0; drawingContext.shadowOffsetX = 0; drawingContext.shadowOffsetY = 0;
             noStroke();
             fill(player.color[0]*0.7, player.color[1]*0.7, player.color[2]*0.8); ellipse(player.x, player.y, player.r * 1.4);
             fill(ai.color[0]*0.8, ai.color[1]*0.7, ai.color[2]*0.7); ellipse(ai.x, ai.y, ai.r * 1.4);
        }

        // --- Малювання шайби з тінню та відблиском ---
        function drawPuck() {
            if (!puck) return;
            drawingContext.shadowBlur = 8; drawingContext.shadowColor = 'rgba(0, 0, 0, 0.35)';
            drawingContext.shadowOffsetX = 2; drawingContext.shadowOffsetY = 3;
            fill(puck.color[0], puck.color[1], puck.color[2]); ellipse(puck.x, puck.y, puck.r * 2);
            drawingContext.shadowBlur = 0; drawingContext.shadowOffsetX = 0; drawingContext.shadowOffsetY = 0;
            let highlightSize = puck.r * 0.6; let highlightX = puck.x - puck.r * 0.2; let highlightY = puck.y - puck.r * 0.2;
            fill(255, 255, 255, 100); ellipse(highlightX, highlightY, highlightSize*1.5, highlightSize*1.2);
             stroke(0, 0, 0, 100); strokeWeight(0.5); noFill(); ellipse(puck.x, puck.y, puck.r * 2);
             noStroke(); fill(255);
        }

         // --- Малювання сліду шайби ---
         function drawTrail() {
             if (!puck || puckTrail.length < 2) return;
             noStroke();
             for (let i = 0; i < puckTrail.length; i++) {
                 let p = puckTrail[i];
                 let alpha = map(i, 0, puckTrail.length - 1, 0, 60);
                 let size = map(i, 0, puckTrail.length - 1, puck.r * 0.2, puck.r * 1.8);
                 fill(puck.color[0], puck.color[1], puck.color[2], alpha); ellipse(p.x, p.y, size);
             }
         }

         // --- Малювання іскор ---
         function drawSparks() {
             if (hitSparks.length === 0) return;
             push(); noStroke();
             for (let spark of hitSparks) {
                  let alpha = map(spark.life, 0, SPARK_LIFETIME, 0, 255);
                  fill(255, 255, 200 + random(-50, 55), alpha); ellipse(spark.x, spark.y, spark.size);
             } pop();
         }

        // --- Скидання раунду після голу або застрягання ШІ ---
        function resetRound(aiJustScoredOrStuck) {
            //("Resetting round. AI scored/stuck:", aiJustScoredOrStuck, " Score:", playerScore, "-", aiScore);
             initializeObjects(aiJustScoredOrStuck); // Скидаємо позиції та подачу
             if (player) { isDragging = false; if (canvasElement) { canvasElement.removeClass('grabbing'); } }
             if (ai) { ai.stuckInCornerTimer = 0; ai.escapeAttemptTimer = 0; ai.lastPuckPosInCorner = { x: -1, y: -1 }; ai.isStuckEscaping = false; }
             puckTrail = []; hitSparks = []; goalFlash.active = false;
             showControls(); // Показати панель на початку раунду
        }

    </script>

</body>
</html>