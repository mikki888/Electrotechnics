<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Аерохокей v6 - Просунуте Уникнення Кутів</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #f0f0f0; flex-direction: column; font-family: sans-serif; }
        canvas { border: 2px solid black; display: block; margin-top: 10px; cursor: grab; }
        canvas.grabbing { cursor: grabbing; }
        #difficultySelector { position: absolute; top: 10px; left: 10px; z-index: 10; }
        label { margin-right: 5px; }
         /* **НОВЕ**: Стиль для повзунка */
         #speedControl { position: absolute; top: 40px; left: 10px; z-index: 10; background: rgba(255,255,255,0.8); padding: 5px; border-radius: 5px; }
         #speedControl label { display: block; margin-bottom: 3px; font-size: 0.9em;}
         #speedValue { font-weight: bold; }

    </style>
</head>
<body>

    <div>
        <label for="difficulty">Складність ШІ:</label>
        <select id="difficulty">
            <option value="easy">Легка</option>
            <option value="medium" selected>Середня</option>
            <option value="hard">Важка</option>
        </select>
    </div>

    <!-- **НОВЕ**: Повзунок для швидкості -->
    <div id="speedControl">
         <label for="aiSpeed">Швидкість ШІ: <span id="speedValue">1.0</span>x</label>
         <input type="range" id="aiSpeed" min="0.2" max="2.5" value="1.0" step="0.1">
    </div>


    <script>
        // --- Глобальні налаштування ---
        let canvasWidth = 700;
        let canvasHeight = 400;
        let canvasElement;

        // Кольори
        const playerColor = [0, 0, 255]; const aiColor = [255, 0, 0]; const puckColor = [255, 255, 255];
        const fieldColor = [50, 50, 50]; const scoreColor = [200, 200, 200, 100];

        // Розміри
        const paddleRadius = 30; const puckRadius = 12; const goalWidth = 110;

        // Фізика
        const friction = 0.99; const maxPuckSpeed = 20;
        const hitForceMultiplier = 0.25; const wallRestitution = -0.85;

        // --- Об'єкти гри ---
        let player;
        let ai;
        let puck;

        // --- Стан гри ---
        let playerScore = 0; let aiScore = 0; let difficulty = 'medium'; let isDragging = false;

        // --- Налаштування ШІ ---
        // **НОВЕ**: Глобальний множник швидкості
        let aiGlobalSpeedMultiplier = 1.0; // Можна змінювати повзунком
        const aiBaseX = (canvasWidth / 5) * 4;
        const aiDefensiveLine = (canvasWidth / 6) * 5;
        const aiOffensivePush = paddleRadius * 0.5;
        const aiAimAssist = 0.1;
        const cornerCheckRadius = paddleRadius * 2.0;
        const fieldCenterX = canvasWidth * 0.4; const fieldCenterY = canvasHeight / 2;
        // **НОВЕ**: Параметри для виявлення застрягання
        const STUCK_THRESHOLD_FRAMES = 45; // Кількість кадрів (~0.75 сек), щоб вважатись застряглим
        const STUCK_PUCK_MOVE_THRESHOLD = 0.5; // Наскільки шайба має зрушитись, щоб таймер скинувся

        function setup() {
            canvasElement = createCanvas(canvasWidth, canvasHeight);
            canvasElement.parent(document.body);

            player = { x: canvasWidth / 4, y: canvasHeight / 2, r: paddleRadius, color: playerColor, prevX: canvasWidth / 4, prevY: canvasHeight / 2, velX: 0, velY: 0 };
            ai = {
                x: aiBaseX, y: canvasHeight / 2, r: paddleRadius, color: aiColor,
                prevX: aiBaseX, prevY: canvasHeight / 2, velX: 0, velY: 0,
                // **НОВЕ**: Властивості для відстеження застрягання
                stuckInCornerTimer: 0,
                lastPuckPosInCorner: { x: -1, y: -1 }, // Початкова недійсна позиція
                isStuckEscaping: false // Прапорець для тактичного відступу
            };
            puck = { x: canvasWidth / 2, y: canvasHeight / 2, r: puckRadius, vx: 0, vy: 0, color: puckColor };

            textAlign(CENTER, CENTER); noStroke();

            const difficultySelect = document.getElementById('difficulty');
            difficultySelect.addEventListener('change', (event) => { difficulty = event.target.value; });
            difficulty = difficultySelect.value;

             // **НОВЕ**: Обробник для повзунка швидкості
            const speedSlider = document.getElementById('aiSpeed');
            const speedValueSpan = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (event) => {
                aiGlobalSpeedMultiplier = parseFloat(event.target.value);
                speedValueSpan.textContent = aiGlobalSpeedMultiplier.toFixed(1);
            });
             // Встановити початкове значення з повзунка (про всяк випадок)
            aiGlobalSpeedMultiplier = parseFloat(speedSlider.value);
             speedValueSpan.textContent = aiGlobalSpeedMultiplier.toFixed(1);
        }


        function draw() {
            updatePlayerVelocity();
            updateAI(); // Використовує aiGlobalSpeedMultiplier
            updatePuck();
            checkCollisions();
            checkGoal();

            drawBackgroundScore();
            drawField();
            drawPaddles();
            drawPuck();
        }

        function mousePressed() { let d = dist(mouseX, mouseY, player.x, player.y); if (d < player.r) { isDragging = true; canvasElement.addClass('grabbing'); } }
        function mouseDragged() { if (isDragging) { player.prevX = player.x; player.prevY = player.y; player.x = constrain(mouseX, player.r, canvasWidth / 2 - player.r); player.y = constrain(mouseY, player.r, canvasHeight - player.r); } }
        function mouseReleased() { if (isDragging) { isDragging = false; canvasElement.removeClass('grabbing'); } }

        function updatePlayerVelocity() {
             if (!isDragging) { player.velX *= 0.8; player.velY *= 0.8; if (abs(player.velX) < 0.1) player.velX = 0; if (abs(player.velY) < 0.1) player.velY = 0; }
             else { player.velX = player.x - player.prevX; player.velY = player.y - player.prevY; }
             if (!isDragging) { player.prevX = player.x; player.prevY = player.y; }
        }

        // ==========================================================
        // ===== ОНОВЛЕНА ЛОГІКА ШІ (З Таймером Застрягання) =====
        // ==========================================================
        function updateAI() {
            ai.prevX = ai.x;
            ai.prevY = ai.y;

            let baseSpeedFactor;
             // **ОНОВЛЕНО**: Зменшені базові швидкості в ~1.5 рази від v4
            switch (difficulty) {
                case 'easy':   baseSpeedFactor = 0.05; break; // Було 0.08
                case 'hard':   baseSpeedFactor = 0.18; break; // Було 0.27
                case 'medium': default: baseSpeedFactor = 0.11; break; // Було 0.16
            }
             // **ОНОВЛЕНО**: Застосування глобального множника
             baseSpeedFactor *= aiGlobalSpeedMultiplier;

            let targetX = aiBaseX;
            let targetY = canvasHeight / 2;
            let currentSpeedFactor = baseSpeedFactor;
            let inCorner = false; // Чи знаходимося ми ГЕОМЕТРИЧНО в куті

            // --- Перевірка стану застрягання та Тактичного Відступу ---
             if (ai.isStuckEscaping) {
                 console.log("AI State: TACTICAL RETREAT!");
                 targetX = aiBaseX * 0.95; // Ціль - безпечна точка в центрі своєї половини
                 targetY = canvasHeight / 2;
                 currentSpeedFactor *= 3.0; // Дуже швидко відступати

                 // Перевірка, чи досягли точки відступу
                 if (dist(ai.x, ai.y, targetX, targetY) < paddleRadius * 1.5) {
                     console.log("AI finished retreat.");
                     ai.isStuckEscaping = false; // Завершити відступ
                     ai.stuckInCornerTimer = 0; // Скинути таймер
                 }
             }
             // Якщо не відступаємо, виконуємо звичайну логіку
             else
             {
                const puckDistToGoal = canvasWidth - puck.x;
                const puckSpeed = sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
                const aiDistToPuck = dist(ai.x, ai.y, puck.x, puck.y);

                // --- Геометрична перевірка кута ---
                 let isTopCorner = (puck.y < cornerCheckRadius && ai.y < cornerCheckRadius * 1.2); // Трохи ширше для ШІ
                 let isBottomCorner = (puck.y > canvasHeight - cornerCheckRadius && ai.y > canvasHeight - cornerCheckRadius * 1.2);
                 let isRightSide = (puck.x > canvasWidth - cornerCheckRadius && ai.x > canvasWidth - cornerCheckRadius * 1.5);
                 inCorner = isRightSide && (isTopCorner || isBottomCorner);


                // --- ВИЗНАЧЕННЯ СТРАТЕГІЇ ---

                // 1. НАЙВИЩИЙ ПРІОРИТЕТ: Захист воріт
                if (puck.x > ai.x && puck.x > aiDefensiveLine && !inCorner) { // Не захищатись, якщо вже в куті
                    console.log("AI State: DEFENSE!");
                     targetX = puck.x + paddleRadius;
                     let interceptY = puck.y + puck.vy * (dist(puck.x, puck.y, canvasWidth, canvasHeight / 2) / (puckSpeed + 0.1)) * 0.5;
                     targetY = lerp(puck.y, constrain(interceptY, puck.r, canvasHeight-puck.r), 0.5);
                     targetX = constrain(targetX, canvasWidth/2 + ai.r, canvasWidth - ai.r);
                     if (puckDistToGoal < ai.r * 2) { targetX = puck.x - ai.r * 0.5; targetY = puck.y; }
                     currentSpeedFactor *= 1.8 * aiGlobalSpeedMultiplier; // Швидкість захисту теж масштабується
                     ai.stuckInCornerTimer = 0; // Скинути таймер, якщо перейшли в захист
                }
                // 2. ЛОГІКА КУТІВ ТА АКТИВНОЇ ГРИ
                else {
                    // Якщо ГЕОМЕТРИЧНО в куті
                    if (inCorner && aiDistToPuck < (ai.r + puck.r + paddleRadius)) {
                        console.log("AI State: Corner Detected");
                        // Перевірка, чи шайба рухалась
                        let puckMovedSignificantly = dist(puck.x, puck.y, ai.lastPuckPosInCorner.x, ai.lastPuckPosInCorner.y) > STUCK_PUCK_MOVE_THRESHOLD;

                        if (puckMovedSignificantly || ai.lastPuckPosInCorner.x < 0) { // Якщо шайба рухалась АБО це перший вхід в кут
                            ai.stuckInCornerTimer = 0; // Скинути таймер
                            ai.lastPuckPosInCorner = { x: puck.x, y: puck.y }; // Оновити позицію
                            console.log("Corner: Puck moved or first entry. Timer reset.");
                        } else {
                            ai.stuckInCornerTimer++; // Інкрементувати таймер, якщо шайба не рухалась
                            console.log(`Corner: Puck stuck. Timer: ${ai.stuckInCornerTimer}/${STUCK_THRESHOLD_FRAMES}`);
                        }

                        // Перевірка, чи застрягли
                        if (ai.stuckInCornerTimer > STUCK_THRESHOLD_FRAMES) {
                             console.log("AI detected STUCK state! Initiating tactical retreat.");
                             ai.isStuckEscaping = true; // Почати тактичний відступ наступного кадру
                             targetX = ai.x; targetY = ai.y; // Залишитись на місці цей кадр
                        }
                        // Якщо не застрягли - СПРОБА ВИБИТИ (Етап 1)
                        else {
                            console.log("Corner: Attempting normal escape.");
                            let escapeVectorX = fieldCenterX - puck.x;
                            let escapeVectorY = fieldCenterY - puck.y;
                            let mag = sqrt(escapeVectorX * escapeVectorX + escapeVectorY * escapeVectorY);
                            if (mag > 0.1) {
                                let escapeDirX = escapeVectorX / mag; let escapeDirY = escapeVectorY / mag;
                                let idealOffset = ai.r + puck.r * 0.5; // Трохи ближче для удару
                                targetX = puck.x - escapeDirX * idealOffset;
                                targetY = puck.y - escapeDirY * idealOffset;
                                // Додаткове відштовхування від стін
                                if (isTopCorner) targetY = max(targetY, ai.y + 2); // Не дати рухатись вгору
                                if (isBottomCorner) targetY = min(targetY, ai.y - 2); // Не дати рухатись вниз
                                targetX = min(targetX, ai.x - 2); // Не дати рухатись вправо

                            } else { targetX = aiBaseX; targetY = fieldCenterY; }
                            currentSpeedFactor *= 2.0 * aiGlobalSpeedMultiplier; // Прискорена спроба вибити
                        }
                    }
                    // Якщо НЕ в куті - стандартна логіка
                    else {
                         ai.stuckInCornerTimer = 0; // Скинути таймер, якщо вийшли з кута
                         ai.lastPuckPosInCorner = { x: -1, y: -1 }; // Скинути позицію

                        // Активна гра
                        if (puck.x > canvasWidth / 2 - puck.r) {
                            console.log("AI State: ACTIVE PLAY");
                            targetX = puck.x - aiOffensivePush - (puckSpeed * 0.5);
                            targetX = max(canvasWidth / 2 + ai.r, targetX);
                            targetY = puck.y;
                            let playerDistY = abs(player.y - canvasHeight/2);
                             if (dist(ai.x, ai.y, player.x, player.y) > canvasWidth / 3 && playerDistY > goalWidth/3 ) {
                                if (player.y < canvasHeight / 2) { targetY = puck.y + aiAimAssist * canvasHeight; targetX -= puck.r; }
                                else { targetY = puck.y - aiAimAssist * canvasHeight; targetX -= puck.r; }
                             }
                            currentSpeedFactor *= map(puckSpeed, 0, maxPuckSpeed, 1.0, 1.5) * aiGlobalSpeedMultiplier;
                        }
                        // Очікування
                        else {
                            console.log("AI State: WAITING");
                            targetX = aiBaseX;
                            targetY = canvasHeight / 2;
                            currentSpeedFactor *= 0.7 * aiGlobalSpeedMultiplier;
                        }
                    }
                }
             } // Кінець блоку if (!ai.isStuckEscaping)


            // --- ЗАСТОСУВАННЯ РУХУ ---
            targetX = constrain(targetX, canvasWidth / 2 + ai.r, canvasWidth - ai.r);
            targetY = constrain(targetY, ai.r, canvasHeight - ai.r);

            // Використовуємо lerp тільки якщо не відступаємо (для різкого руху)
            if (!ai.isStuckEscaping) {
                 ai.x = lerp(ai.x, targetX, currentSpeedFactor);
                 ai.y = lerp(ai.y, targetY, currentSpeedFactor);
            } else {
                // Прямий рух до точки відступу
                 let moveX = targetX - ai.x;
                 let moveY = targetY - ai.y;
                 let moveMag = sqrt(moveX*moveX + moveY*moveY);
                 let maxMove = baseSpeedFactor * 15; // Максимальна швидкість відступу
                 if (moveMag > maxMove) {
                     moveX = (moveX / moveMag) * maxMove;
                     moveY = (moveY / moveMag) * maxMove;
                 }
                 ai.x += moveX;
                 ai.y += moveY;
            }


            const borderMargin = 1;
            ai.x = constrain(ai.x, canvasWidth / 2 + ai.r + borderMargin, canvasWidth - ai.r - borderMargin);
            ai.y = constrain(ai.y, ai.r + borderMargin, canvasHeight - ai.r - borderMargin);

            ai.velX = ai.x - ai.prevX;
            ai.velY = ai.y - ai.prevY;
        }
        // ==========================================================
        // ===== КІНЕЦЬ ОНОВЛЕНОЇ ЛОГІКИ ШІ ========================
        // ==========================================================


        function updatePuck() { /* ... (код без змін) ... */ puck.x += puck.vx; puck.y += puck.vy; puck.vx *= friction; puck.vy *= friction; let speed = sqrt(puck.vx*puck.vx + puck.vy*puck.vy); if (speed > maxPuckSpeed) { puck.vx = (puck.vx / speed) * maxPuckSpeed; puck.vy = (puck.vy / speed) * maxPuckSpeed; } if (speed < 0.1) { puck.vx = 0; puck.vy = 0; } const goalTop = canvasHeight / 2 - goalWidth / 2; const goalBottom = canvasHeight / 2 + goalWidth / 2; const borderMargin = 1; if (puck.y - puck.r < 0) { puck.vy *= wallRestitution; puck.y = puck.r + borderMargin; puck.vx *= friction; } else if (puck.y + puck.r > canvasHeight) { puck.vy *= wallRestitution; puck.y = canvasHeight - puck.r - borderMargin; puck.vx *= friction; } if (puck.x - puck.r < 0) { if (puck.y < goalTop || puck.y > goalBottom) { puck.vx *= wallRestitution; puck.x = puck.r + borderMargin; puck.vy *= friction; } } else if (puck.x + puck.r > canvasWidth) { if (puck.y < goalTop || puck.y > goalBottom) { puck.vx *= wallRestitution; puck.x = canvasWidth - puck.r - borderMargin; puck.vy *= friction; } } puck.x = constrain(puck.x, -puck.r*2, canvasWidth + puck.r*2); puck.y = constrain(puck.y, puck.r, canvasHeight - puck.r); }
        function checkCollisions() { if (isDragging || dist(player.x, player.y, puck.x, puck.y) < player.r + puck.r + 10) { handlePaddleCollision(player); } handlePaddleCollision(ai); }
        function handlePaddleCollision(paddle) { let dx = puck.x - paddle.x; let dy = puck.y - paddle.y; let distance = sqrt(dx*dx + dy*dy); let minDistance = puck.r + paddle.r; if (distance < minDistance) { let angle = atan2(dy, dx); let baseSpeed = 7; let paddleVelMagnitude = sqrt(paddle.velX*paddle.velX + paddle.velY*paddle.velY); let totalSpeed = baseSpeed + paddleVelMagnitude * hitForceMultiplier * 1.5; totalSpeed = min(totalSpeed, maxPuckSpeed * 1.1); puck.vx = cos(angle) * totalSpeed; puck.vy = sin(angle) * totalSpeed; let overlap = minDistance - distance; let pushFactor = 1.1; puck.x += cos(angle) * (overlap * pushFactor + 1); puck.y += sin(angle) * (overlap * pushFactor + 1); dx = puck.x - paddle.x; dy = puck.y - paddle.y; distance = sqrt(dx*dx + dy*dy); if (distance < minDistance) { puck.x = paddle.x + cos(angle) * (minDistance + 0.1); puck.y = paddle.y + sin(angle) * (minDistance + 0.1); } let currentSpeed = sqrt(puck.vx*puck.vx + puck.vy*puck.vy); if (currentSpeed > maxPuckSpeed) { puck.vx = (puck.vx / currentSpeed) * maxPuckSpeed; puck.vy = (puck.vy / currentSpeed) * maxPuckSpeed; } } }
        function checkGoal() { const goalTop = canvasHeight / 2 - goalWidth / 2; const goalBottom = canvasHeight / 2 + goalWidth / 2; if (puck.x < puck.r && puck.y > goalTop && puck.y < goalBottom) { aiScore++; resetRound(true); } if (puck.x > canvasWidth - puck.r && puck.y > goalTop && puck.y < goalBottom) { playerScore++; resetRound(false); } }
        function drawBackgroundScore() { background(fieldColor[0], fieldColor[1], fieldColor[2]); fill(scoreColor[0], scoreColor[1], scoreColor[2], scoreColor[3]); textSize(150); text(`${playerScore} - ${aiScore}`, canvasWidth / 2, canvasHeight / 2); }
        function drawField() { stroke(200); strokeWeight(4); line(canvasWidth / 2, 0, canvasWidth / 2, canvasHeight); noFill(); ellipse(canvasWidth / 2, canvasHeight / 2, 80, 80); const goalY1 = canvasHeight / 2 - goalWidth / 2; const goalY2 = canvasHeight / 2 + goalWidth / 2; stroke(playerColor[0], playerColor[1], playerColor[2], 150); line(0, goalY1, 0, goalY2); stroke(aiColor[0], aiColor[1], aiColor[2], 150); line(canvasWidth, goalY1, canvasWidth, goalY2); noStroke(); }
        function drawPaddles() { fill(player.color[0], player.color[1], player.color[2]); ellipse(player.x, player.y, player.r * 2); fill(ai.color[0], ai.color[1], ai.color[2]); ellipse(ai.x, ai.y, ai.r * 2); }
        function drawPuck() { fill(puck.color[0], puck.color[1], puck.color[2]); ellipse(puck.x, puck.y, puck.r * 2); }

        function resetRound(aiScored) {
            puck.x = canvasWidth / 2; puck.y = canvasHeight / 2;
            puck.vx = aiScored ? random(2, 4) : random(-4, -2); puck.vy = random(-1.5, 1.5);

            player.x = canvasWidth / 4; player.y = canvasHeight / 2;
            player.velX = 0; player.velY = 0; player.prevX = player.x; player.prevY = player.y;
            isDragging = false; canvasElement.removeClass('grabbing');

            ai.x = aiBaseX; ai.y = canvasHeight / 2;
            ai.velX = 0; ai.velY = 0; ai.prevX = ai.x; ai.prevY = ai.y;
            // **НОВЕ**: Скидання стану застрягання при новому раунді
            ai.stuckInCornerTimer = 0;
            ai.lastPuckPosInCorner = { x: -1, y: -1 };
            ai.isStuckEscaping = false;

             console.log("Раунд скинуто. Рахунок:", playerScore, "-", aiScore);
        }

    </script>

</body>
</html>