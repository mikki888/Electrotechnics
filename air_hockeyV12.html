<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2D Аерохокей v11 - Покращений ШІ (Передбачення та Прицілювання)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        /* Стилі залишаються ті ж самі */
        body { display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; margin: 0; background-color: #333; flex-direction: column; font-family: sans-serif; -webkit-user-select: none; -ms-user-select: none; user-select: none; overflow: hidden; color: white; }
        canvas { border: 2px solid #aaa; display: block; cursor: grab; touch-action: none; max-width: 100%; max-height: 100%; box-sizing: border-box; }
        canvas.grabbing { cursor: grabbing; }
        .controls { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0, 0, 0, 0.6); padding: 8px; border-radius: 5px; font-size: 0.9em; display: flex; gap: 15px; align-items: center; }
        .control-group label { margin-right: 5px; }
        #speedValue { font-weight: bold; }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label for="difficulty">Складність:</label>
            <select id="difficulty"> <option value="easy">Легка</option> <option value="medium" selected>Середня</option> <option value="hard">Важка</option> </select>
        </div>
        <div class="control-group">
             <label for="aiSpeed">Шв. ШІ: <span id="speedValue">1.0</span>x</label>
             <input type="range" id="aiSpeed" min="0.2" max="2.5" value="1.0" step="0.1" style="width: 80px;">
        </div>
    </div>

    <script>
        // --- Глобальні налаштування ---
        let canvasElement; let isPortrait = false; const padding = 10;
    
        // Кольори та Розміри
        const playerColor = [0, 0, 255]; const aiColor = [255, 0, 0]; const puckColor = [255, 255, 255];
        const fieldColor = [50, 50, 50]; const scoreColor = [200, 200, 200, 100];
        let paddleRadius; let puckRadius; let goalWidth;
    
        // Фізика
        const friction = 0.995; const maxPuckSpeed = 20;
        const hitForceMultiplier = 0.25;
        const wallRestitution = -0.95;
    
        // --- Об'єкти гри ---
        let player; let ai; let puck;
    
        // --- Стан гри ---
        let playerScore = 0; let aiScore = 0; let difficulty = 'medium'; let isDragging = false;
    
        // --- Налаштування ШІ ---
        let aiGlobalSpeedMultiplier = 1.0;
        let aiBasePos; let aiDefensiveLine; let aiCriticalDefenseLine;
        let aiOffensivePush;
        const aiAimAssist = 0.1;
        let cornerCheckRadius;
        const wallAvoidanceDistance = 50;
        const wallAvoidanceForce = 0.2;
        let scaledWallAvoidDistance;
        const STUCK_THRESHOLD_FRAMES = 45;
        const STUCK_ESCAPE_FORCE = 6;
    
        // **НОВІ ПАРАМЕТРИ ШІ v11**
        const AI_PREDICTION_FRAMES_MIN = 8;
        const AI_PREDICTION_FRAMES_MAX = 25;
        const AI_DEFENSE_CLEAR_BIAS = 0.25;
        const AI_OFFENSIVE_AIM_THRESH = 1.5;
        const AI_CRITICAL_CLEAR_STRENGTH = 1.0;
    
        function setup() {
            let dims = calculateCanvasSize();
            canvasElement = createCanvas(dims.w, dims.h);
            canvasElement.parent(document.body);
            isPortrait = dims.portrait;
            resetLayout();
            textAlign(CENTER, CENTER);
            noStroke();
            setupEventListeners();
        }
    
        function calculateCanvasSize() {
            let availableWidth = windowWidth - padding * 2;
            let availableHeight = windowHeight - padding * 2 - 50; // Minus space for controls potentially
            availableHeight = max(availableHeight, 200); // Minimum height
            let portrait = availableHeight > availableWidth;
            // Ensure dimensions are integers for canvas creation
            return { w: floor(availableWidth), h: floor(availableHeight), portrait: portrait };
        }
    
        function resetLayout() {
            console.log(`Resetting layout. Width: ${width}, Height: ${height}, Portrait: ${isPortrait}`);
            let minDim = min(width, height);
            paddleRadius = max(25, minDim * 0.05);
            puckRadius = max(8, minDim * 0.03);
            goalWidth = minDim * 0.3;
            aiOffensivePush = paddleRadius * 0.7;
            cornerCheckRadius = paddleRadius * 1.8;
            scaledWallAvoidDistance = minDim * 0.13;
    
            if (isPortrait) {
                aiBasePos = { x: width / 2, y: height * 0.25 };
                aiDefensiveLine = height * 0.40;
                aiCriticalDefenseLine = height * 0.18;
                player = { x: width / 2, y: height * 0.75, r: paddleRadius, color: playerColor, prevX: width/2, prevY: height*0.75, velX: 0, velY: 0 };
                ai = { x: aiBasePos.x, y: aiBasePos.y, r: paddleRadius, color: aiColor, prevX: aiBasePos.x, prevY: aiBasePos.y, velX: 0, velY: 0, stuckInCornerTimer: 0, lastPuckPosInCorner: { x: -1, y: -1 }, isStuckEscaping: false };
                puck = { x: width / 2, y: height / 2, r: puckRadius, vx: 0, vy: random(-2, 2), color: puckColor };
            } else { // Landscape
                aiBasePos = { x: width * 0.75, y: height / 2 };
                aiDefensiveLine = width * 0.60;
                aiCriticalDefenseLine = width * 0.82;
                player = { x: width * 0.25, y: height / 2, r: paddleRadius, color: playerColor, prevX: width*0.25, prevY: height/2, velX: 0, velY: 0 };
                ai = { x: aiBasePos.x, y: aiBasePos.y, r: paddleRadius, color: aiColor, prevX: aiBasePos.x, prevY: aiBasePos.y, velX: 0, velY: 0, stuckInCornerTimer: 0, lastPuckPosInCorner: { x: -1, y: -1 }, isStuckEscaping: false };
                puck = { x: width / 2, y: height / 2, r: puckRadius, vx: random(-2, 2), vy: 0, color: puckColor };
            }
            isDragging = false;
            if (canvasElement) { // Check if canvasElement exists before removing class
                 canvasElement.removeClass('grabbing');
            }
        }
    
        function windowResized() {
            let dims = calculateCanvasSize();
            resizeCanvas(dims.w, dims.h);
            // Check if orientation changed significantly
            if (dims.portrait !== isPortrait) {
                isPortrait = dims.portrait;
                resetLayout(); // Full reset if orientation changes
            } else {
                resetLayout(); // Reset layout even if orientation is same (size might have changed)
            }
        }
    
        function setupEventListeners() {
            const difficultySelect = document.getElementById('difficulty');
            difficultySelect.addEventListener('change', (event) => {
                difficulty = event.target.value;
                console.log("Difficulty changed to:", difficulty); // Add log
                // Maybe reset AI state or puck here if needed on difficulty change?
            });
            // Ensure initial value is set correctly
            difficulty = difficultySelect.value;
    
            const speedSlider = document.getElementById('aiSpeed');
            const speedValueSpan = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (event) => {
                aiGlobalSpeedMultiplier = parseFloat(event.target.value);
                speedValueSpan.textContent = aiGlobalSpeedMultiplier.toFixed(1);
            });
             // Ensure initial value is set correctly
            aiGlobalSpeedMultiplier = parseFloat(speedSlider.value);
            speedValueSpan.textContent = aiGlobalSpeedMultiplier.toFixed(1);
    
            // Touch Listeners
            canvasElement.elt.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvasElement.elt.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvasElement.elt.addEventListener('touchend', handleTouchEnd);
            canvasElement.elt.addEventListener('touchcancel', handleTouchEnd);
    
            // Mouse Listeners (using p5 methods)
            canvasElement.mousePressed(handleMousePressed);
            // Use mouseDragged for continuous movement while pressed
            canvasElement.mouseMoved(handleMouseDragged); // Правильно
            canvasElement.mouseReleased(handleMouseReleased);
        }
    
        function handleTouchStart(event) {
            // Prevent default touch behavior like scrolling/zooming
            // event.preventDefault(); // Already handled by passive: false and touch-action: none in CSS
            if (event.touches.length > 0) {
                let touch = event.touches[0];
                // Get touch position relative to the canvas
                let rect = canvasElement.elt.getBoundingClientRect();
                let x = touch.clientX - rect.left;
                let y = touch.clientY - rect.top;
                checkPaddleGrab(x, y);
            }
        }
    
        function handleTouchMove(event) {
            if (isDragging && event.touches.length > 0) {
                event.preventDefault(); // Prevent scrolling while dragging paddle
                let touch = event.touches[0];
                let rect = canvasElement.elt.getBoundingClientRect();
                let x = touch.clientX - rect.left;
                let y = touch.clientY - rect.top;
                updatePlayerPosition(x, y);
            }
        }
    
        function handleTouchEnd(event) {
            // If the touch ending corresponds to the one dragging the paddle
            if (isDragging) { // Check if we were dragging, not just any touch end
                 releasePaddleGrab();
            }
        }
    
        function handleMousePressed() {
            // mouseX and mouseY are p5 global variables for mouse position relative to canvas
            checkPaddleGrab(mouseX, mouseY);
        }
    
        function handleMouseDragged() {
            if (isDragging) {
                updatePlayerPosition(mouseX, mouseY);
            }
        }
    
        function handleMouseReleased() {
            if (isDragging) {
                releasePaddleGrab();
            }
        }
    
        function checkPaddleGrab(x, y) {
            let d = dist(x, y, player.x, player.y);
            // Increase grab radius slightly for easier interaction
            if (d < player.r * 1.8) {
                isDragging = true;
                canvasElement.addClass('grabbing');
            }
        }
    
        function releasePaddleGrab() {
            isDragging = false;
            canvasElement.removeClass('grabbing');
        }
    
        function updatePlayerPosition(newX, newY) {
            player.prevX = player.x;
            player.prevY = player.y;
    
            let limitY1, limitY2, limitX1, limitX2;
            if (isPortrait) {
                limitX1 = player.r;
                limitX2 = width - player.r;
                limitY1 = height / 2 + player.r; // Player stays in bottom half
                limitY2 = height - player.r;
            } else { // Landscape
                limitX1 = player.r;
                limitX2 = width / 2 - player.r; // Player stays in left half
                limitY1 = player.r;
                limitY2 = height - player.r;
            }
            player.x = constrain(newX, limitX1, limitX2);
            player.y = constrain(newY, limitY1, limitY2);
        }
    
        function draw() {
            background(fieldColor[0], fieldColor[1], fieldColor[2]);
            updatePlayerVelocity();
            updateAI(); // AI logic update
            updatePuck(); // Puck physics update
            checkCollisions(); // Check paddle/puck collisions
            checkGoal(); // Check if score occurred
            drawField(); // Draw background elements
            drawBackgroundScore(); // Draw score text
            drawPaddles(); // Draw player and AI paddles
            drawPuck(); // Draw the puck
        }
    
        function updatePlayerVelocity() {
            if (!isDragging) {
                // Apply friction if not dragging
                player.velX *= 0.8; // Friction factor
                player.velY *= 0.8;
                // Stop movement if velocity is very low
                if (abs(player.velX) < 0.1) player.velX = 0;
                if (abs(player.velY) < 0.1) player.velY = 0;
                 // Move player based on velocity ONLY if not dragging
                 // updatePlayerPosition(player.x + player.velX, player.y + player.velY); // Optional: allow coasting
            } else {
                // Calculate velocity based on drag movement
                player.velX = player.x - player.prevX;
                player.velY = player.y - player.prevY;
            }
            // Update previous position if not dragging (needed for next frame velocity calc if drag starts)
            // Moved this update inside the else block of isDragging check might be better
            // if (!isDragging) {
            //     player.prevX = player.x;
            //     player.prevY = player.y;
            // }
             // Simpler: always update prev position for velocity calculation next frame
             // player.prevX = player.x; // Already done in updatePlayerPosition
             // player.prevY = player.y;
        }
    
        // ==========================================================
        // ===== ОНОВЛЕНА ЛОГІКА ШІ v11.3 =========================
        // ==========================================================
        function updateAI() {
            ai.prevX = ai.x;
            ai.prevY = ai.y;

            // --- Базова швидкість ---
            let baseSpeedFactor;
            switch (difficulty) {
                case 'easy': baseSpeedFactor = 0.07; break;
                case 'hard': baseSpeedFactor = 0.25; break;
                case 'medium': default: baseSpeedFactor = 0.15; break;
            }
            baseSpeedFactor *= aiGlobalSpeedMultiplier*0.7;

            // --- Цільова позиція та швидкість ---
            let targetX = aiBasePos.x;
            let targetY = aiBasePos.y;
            let currentSpeedFactor = baseSpeedFactor;
            let avoidanceForce = { x: 0, y: 0 };

            // --- Координати воріт ---
            const aiGoalX = isPortrait ? width / 2 : width;
            const aiGoalY = isPortrait ? 0 : height / 2; // Центр лінії воріт AI
            const playerGoalX = isPortrait ? width / 2 : 0;
            const playerGoalY = isPortrait ? height : height / 2;

            // --- Розрахунок передбачення (використовується для звичайних станів) ---
            const aiDistToPuck = dist(ai.x, ai.y, puck.x, puck.y);
            const puckSpeed = sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
            let predictionTime = map(aiDistToPuck, 0, max(width, height) / 2, AI_PREDICTION_FRAMES_MIN, AI_PREDICTION_FRAMES_MAX);
            predictionTime /= map(puckSpeed, 0, maxPuckSpeed * 0.8, 1, 3.0);
            predictionTime = constrain(predictionTime, 2, AI_PREDICTION_FRAMES_MAX);
            let predictedPuckX = puck.x + puck.vx * predictionTime;
            let predictedPuckY = puck.y + puck.vy * predictionTime;
            predictedPuckX = constrain(predictedPuckX, puckRadius, width - puckRadius);
            predictedPuckY = constrain(predictedPuckY, puckRadius, height - puckRadius);

            // --- Перевірка руху шайби до воріт ШІ ---
            let isPuckMovingTowardsAIGoal = false;
            if (isPortrait) { isPuckMovingTowardsAIGoal = puck.vy < -0.2; } // Менш строга перевірка напрямку
            else { isPuckMovingTowardsAIGoal = puck.vx > 0.2; }


            // -----------------------------------------
            // --- ЛОГІКА СТАНІВ ШІ (з пріоритетами) ---
            // -----------------------------------------
            let forcedAction = false; // Прапорець для примусової дії

            // --- **НОВЕ**: ПРІОРИТЕТ 1: Шайба за спиною біля воріт ---
            let puckNearGoalLine = false;
            let puckBehindAI = false;
            const desperationDistance = paddleRadius * 2.5; // Як близько до лінії воріт

            if (isPortrait) {
                puckNearGoalLine = puck.y < desperationDistance;
                puckBehindAI = puck.y < ai.y;
            } else { // Landscape
                puckNearGoalLine = puck.x > width - desperationDistance;
                puckBehindAI = puck.x > ai.x;
            }

            if (puckNearGoalLine && puckBehindAI && isPuckMovingTowardsAIGoal) {
                 console.log("AI State: !!! DESPERATION SAVE !!! (Puck Behind)");
                 // Ціль: лінія воріт на рівні поточної позиції шайби
                 targetX = isPortrait ? puck.x : width - ai.r; // Стати на лінію X шайби або біля стінки
                 targetY = isPortrait ? ai.r : puck.y;     // Стати біля верхньої стінки або на лінію Y шайби

                 // Обмежити ціль воротами
                 let goalMin = isPortrait ? (width/2 - goalWidth/2) : (height/2 - goalWidth/2);
                 let goalMax = isPortrait ? (width/2 + goalWidth/2) : (height/2 + goalWidth/2);
                 if(isPortrait) targetX = constrain(targetX, goalMin, goalMax);
                 else targetY = constrain(targetY, goalMin, goalMax);

                 targetX = constrain(targetX, ai.r, width - ai.r); // Загальне обмеження поля
                 targetY = constrain(targetY, ai.r, height - ai.r); // Загальне обмеження поля

                 currentSpeedFactor *= 5.0 * aiGlobalSpeedMultiplier*0.7; // МАКСИМАЛЬНА ШВИДКІСТЬ
                 forcedAction = true;
                 ai.stuckInCornerTimer = 0; // Скидаємо таймер кута
            }

            // --- ПРІОРИТЕТ 2: Відлипання від кута ---
            else if (ai.isStuckEscaping && !forcedAction) {
                console.log("AI State: STUCK ESCAPE MOVE!");
                 let escapeDirX = width / 2 - ai.x; let escapeDirY = height / 2 - ai.y;
                 let escapeMag = sqrt(escapeDirX*escapeDirX + escapeDirY*escapeDirY);
                 if (escapeMag > 1){ escapeDirX /= escapeMag; escapeDirY /= escapeMag;}
                 targetX = ai.x + escapeDirX * STUCK_ESCAPE_FORCE * 5;
                 targetY = ai.y + escapeDirY * STUCK_ESCAPE_FORCE * 5;
                 currentSpeedFactor *= 4.5;
                 ai.isStuckEscaping = false;
                 ai.stuckInCornerTimer = 0;
                 forcedAction = true;
                 console.log("AI finished escape attempt.");
            }
             // --- ПРІОРИТЕТ 3: Підштовхування повільної шайби БІЛЯ БОРТУ/КУТА ---
            else if (puckSpeed < 0.4 && !ai.isStuckEscaping && !forcedAction) {
                 let isOnAiHalf = isPortrait ? (puck.y < height / 2 + paddleRadius) : (puck.x > width / 2 - paddleRadius);
                 if (isOnAiHalf) {
                    let isNearEdge = false; const edgeDistance = paddleRadius * 3.0;
                    if (isPortrait) { if (puck.y < height / 2 && (puck.x < edgeDistance || puck.x > width - edgeDistance)) { isNearEdge = true; }}
                    else { if (puck.x > width / 2 && (puck.y < edgeDistance || puck.y > height - edgeDistance)) { isNearEdge = true; }}

                    if (isNearEdge) {
                         console.log("AI State: NUDGING SLOW PUCK (Near Edge)");
                         let pushTargetX = width / 2; let pushTargetY = height / 2;
                         let pushVecX = pushTargetX - puck.x; let pushVecY = pushTargetY - puck.y;
                         let pushMag = sqrt(pushVecX*pushVecX + pushVecY*pushVecY);
                         if (pushMag > 0.1) { pushVecX /= pushMag; pushVecY /= pushMag; }
                         else { pushVecX = isPortrait ? 0 : -1; pushVecY = isPortrait ? 1 : 0; }
                         targetX = puck.x - pushVecX * (ai.r * 0.6); targetY = puck.y - pushVecY * (ai.r * 0.6);
                         currentSpeedFactor *= 1.8 * aiGlobalSpeedMultiplier*0.7;
                         forcedAction = true;
                         ai.stuckInCornerTimer = 0;
                    }
                 }
            }

            // --- ЗВИЧАЙНА ЛОГІКА (якщо не було примусової дії) ---
            if (!forcedAction) {
                // --- Визначення стратегії (використовуємо передбачення і напрямок) ---
                 let criticalCheck = isPortrait
                     ? (predictedPuckY < aiCriticalDefenseLine && isPuckMovingTowardsAIGoal)
                     : (predictedPuckX > aiCriticalDefenseLine && isPuckMovingTowardsAIGoal);

                 let defenseCheck = isPortrait
                     ? (predictedPuckY < aiDefensiveLine && isPuckMovingTowardsAIGoal) // **ДОДАНО**: Перевірка напрямку
                     : (predictedPuckX > aiDefensiveLine && isPuckMovingTowardsAIGoal); // **ДОДАНО**: Перевірка напрямку

                // --- СТАН: КРИТИЧНИЙ ЗАХИСТ ---
                if (criticalCheck) {
                    console.log("AI State: !!! CRITICAL DEFENSE !!!");
                     let clearTargetX, clearTargetY; if(isPortrait){/*...*/}else{/*...*/} let clearVectorX = clearTargetX - predictedPuckX; let clearVectorY = clearTargetY - predictedPuckY; let mag=sqrt(/*...*/); if(mag>0.1){/*...*/} else {/*...*/}
                     currentSpeedFactor *= 4.0 * aiGlobalSpeedMultiplier*0.7;
                     ai.stuckInCornerTimer = 0;
                }
                // --- СТАН: ЗВИЧАЙНИЙ ЗАХИСТ ---
                else if (defenseCheck) {
                     console.log("AI State: DEFENSE (Intercept & Clear)");
                      let interceptX = predictedPuckX; let interceptY = predictedPuckY; if(isPortrait){/*...*/}else{/*...*/}
                      currentSpeedFactor *= 2.2 * aiGlobalSpeedMultiplier*0.7;
                      ai.stuckInCornerTimer = 0;
                }
                // --- СТАН: АКТИВНА ГРА / ОЧІКУВАННЯ ---
                else {
                     let isActiveZone = isPortrait ? (predictedPuckY < height / 2 + puck.r * 3) : (predictedPuckX > width / 2 - puck.r * 3);
                     if (isActiveZone) {
                         console.log("AI State: ACTIVE PLAY (Intercept & Aim)");
                          let aimVecX = playerGoalX - predictedPuckX; let aimVecY = playerGoalY - predictedPuckY; let aimMag = sqrt(aimVecX*aimVecX + aimVecY*aimVecY); if(aimMag > 0.1){aimVecX/=aimMag; aimVecY/=aimMag;}else{/*...*/}
                          targetX = predictedPuckX - aimVecX * aiOffensivePush;
                          targetY = predictedPuckY - aimVecY * aiOffensivePush;
                          let speedBoost = (puckSpeed > 1.0) ? map(puckSpeed, 1, maxPuckSpeed, 1.3, 2.0) : 1.3;
                          currentSpeedFactor *= speedBoost * aiGlobalSpeedMultiplier*0.7;
                          ai.stuckInCornerTimer = 0; // Скидаємо таймер і тут
                     } else {
                          console.log("AI State: WAITING / Returning");
                          targetX = aiBasePos.x; targetY = aiBasePos.y;
                          currentSpeedFactor *= 0.7 * aiGlobalSpeedMultiplier*0.7;
                          // Не скидаємо таймер кута тут, бо ШІ може чекати біля кута
                     }

                     // --- Перевірка застрягання в куті (тільки якщо не захищається/атакує активно) ---
                     // (Виконується тільки якщо ШІ не в CRITICAL/DEFENSE/ACTIVE PLAY)
                     if (!isActiveZone) { // Тільки якщо ШІ в стані WAITING
                        let isNearCorner = false; const checkDist = cornerCheckRadius * 1.1; if(isPortrait){isNearCorner = (ai.y < checkDist + ai.r) && (ai.x < checkDist + ai.r || ai.x > width - checkDist - ai.r);}else{isNearCorner = (ai.x > width - checkDist - ai.r) && (ai.y < checkDist + ai.r || ai.y > height - checkDist - ai.r);}
                        if (isNearCorner && aiDistToPuck < (ai.r + puck.r + paddleRadius * 0.5) ) {
                           if (puckSpeed < 0.3 && ai.lastPuckPosInCorner.x > 0) { ai.stuckInCornerTimer++; console.log(`Corner Timer: ${ai.stuckInCornerTimer}/${STUCK_THRESHOLD_FRAMES}`);} else { ai.stuckInCornerTimer = 0; ai.lastPuckPosInCorner = { x: puck.x, y: puck.y };}
                           if (ai.stuckInCornerTimer > STUCK_THRESHOLD_FRAMES) { ai.isStuckEscaping = true; console.log("!!! TRIGGERING ESCAPE !!!");}
                        } else { ai.stuckInCornerTimer = 0; ai.lastPuckPosInCorner = { x: -1, y: -1 };}
                     } else {
                         // Якщо ШІ в ACTIVE PLAY, він не повинен вважатися застряглим у куті
                         ai.stuckInCornerTimer = 0;
                     }
                } // Кінець Активна/Очікування else
            } // Кінець if (!forcedAction)

            // --- Розрахунок сили уникнення стін --- (Розраховується завжди)
            avoidanceForce = calculateWallAvoidance(ai, isPortrait, scaledWallAvoidDistance, wallAvoidanceForce, aiGoalX, aiGoalY);

            // -----------------------------------------
            // --- ЗАСТОСУВАННЯ РУХУ -------------------
            // -----------------------------------------
            let desiredVelX = (targetX - ai.x) * currentSpeedFactor;
            let desiredVelY = (targetY - ai.y) * currentSpeedFactor;
            desiredVelX += avoidanceForce.x * currentSpeedFactor * 55;
            desiredVelY += avoidanceForce.y * currentSpeedFactor * 55;
            let desiredSpeed = sqrt(desiredVelX * desiredVelX + desiredVelY * desiredVelY);
            let maxAllowedSpeed = baseSpeedFactor * 180;
            if (desiredSpeed > maxAllowedSpeed) { desiredVelX = (desiredVelX / desiredSpeed) * maxAllowedSpeed; desiredVelY = (desiredVelY / desiredSpeed) * maxAllowedSpeed; }

            // Обмеження швидкості, якщо ШІ в стані відчаю (щоб не пролетіти повз)
             if (puckNearGoalLine && puckBehindAI && isPuckMovingTowardsAIGoal && !ai.isStuckEscaping) {
                 const desperationMaxSpeed = maxPuckSpeed * 0.8; // Швидкість обмежена при відчайдушному сейві
                 if (desiredSpeed > desperationMaxSpeed) {
                     desiredVelX = (desiredVelX / desiredSpeed) * desperationMaxSpeed;
                     desiredVelY = (desiredVelY / desiredSpeed) * desperationMaxSpeed;
                 }
             }

            ai.x += desiredVelX;
            ai.y += desiredVelY;

            // --- Обмеження позиції ШІ ---
            const borderMargin = 0.5; let constrainedX = ai.x; let constrainedY = ai.y; if(isPortrait){constrainedX = constrain(ai.x, ai.r + borderMargin, width - ai.r - borderMargin); constrainedY = constrain(ai.y, ai.r + borderMargin, height / 2 - ai.r - borderMargin);}else{constrainedX = constrain(ai.x, width / 2 + ai.r + borderMargin, width - ai.r - borderMargin); constrainedY = constrain(ai.y, ai.r + borderMargin, height - ai.r - borderMargin);}
            ai.x = constrainedX; ai.y = constrainedY;
            ai.velX = ai.x - ai.prevX; ai.velY = ai.y - ai.prevY;
        }
        // ===== Кінець updateAI =====

    
        function calculateWallAvoidance(agent, isPortraitOrientation, avoidDistance, forceMagnitude, goalX, goalY) {
            let totalForce = { x: 0, y: 0 };
            let steer;
            const goalAvoidBoost = 1.6; // Stronger avoidance near own goal
    
            if (isPortraitOrientation) {
                // Top wall (near AI goal Y=0)
                let distToGoalLine = agent.y;
                let boost = (distToGoalLine < avoidDistance * 1.5) ? goalAvoidBoost : 1.0; // Boost if close
                steer = calculateSingleWallAvoidance(agent.y, 0, avoidDistance * boost, forceMagnitude * boost);
                if (steer !== 0) totalForce.y += steer;
    
                // Left wall (X=0)
                steer = calculateSingleWallAvoidance(agent.x, 0, avoidDistance, forceMagnitude);
                if (steer !== 0) totalForce.x += steer;
                // Right wall (X=width)
                steer = calculateSingleWallAvoidance(agent.x, width, avoidDistance, forceMagnitude);
                if (steer !== 0) totalForce.x += steer;
                // Center line (Y=height/2) - less strong avoidance
                steer = calculateSingleWallAvoidance(agent.y, height / 2, avoidDistance * 0.5, forceMagnitude * 0.4);
                 if (steer !== 0) totalForce.y += steer; // Add force pushing down from center
    
            } else { // Landscape
                 // Right wall (near AI goal X=width)
                 let distToGoalLine = width - agent.x;
                 let boost = (distToGoalLine < avoidDistance * 1.5) ? goalAvoidBoost : 1.0;
                 steer = calculateSingleWallAvoidance(agent.x, width, avoidDistance * boost, forceMagnitude * boost);
                 if (steer !== 0) totalForce.x += steer;
    
                 // Top wall (Y=0)
                 steer = calculateSingleWallAvoidance(agent.y, 0, avoidDistance, forceMagnitude);
                 if (steer !== 0) totalForce.y += steer;
                 // Bottom wall (Y=height)
                 steer = calculateSingleWallAvoidance(agent.y, height, avoidDistance, forceMagnitude);
                 if (steer !== 0) totalForce.y += steer;
                 // Center line (X=width/2) - less strong avoidance
                 steer = calculateSingleWallAvoidance(agent.x, width / 2, avoidDistance * 0.5, forceMagnitude * 0.4);
                 if (steer !== 0) totalForce.x += steer; // Add force pushing left from center
            }
    
            // Optional: Limit the magnitude of the total avoidance force
            // let totalMag = sqrt(totalForce.x * totalForce.x + totalForce.y * totalForce.y);
            // let maxAvoidForce = forceMagnitude * 2.0; // Example limit
            // if (totalMag > maxAvoidForce) {
            //     totalForce.x = (totalForce.x / totalMag) * maxAvoidForce;
            //     totalForce.y = (totalForce.y / totalMag) * maxAvoidForce;
            // }
    
            return totalForce;
        }
    
        function calculateSingleWallAvoidance(agentPos, wallPos, avoidDist, forceMag) {
             let diff = agentPos - wallPos;
             let distToWall = abs(diff);
             // Apply force only if within avoidance distance and not exactly on the wall
             if (distToWall < avoidDist && distToWall > 0.01) {
                 // Force increases sharply as distance decreases (power > 1)
                 let repelForce = pow((avoidDist - distToWall) / avoidDist, 1.8); // Sharper increase
                 // Direction is away from the wall
                 let direction = (diff > 0 ? 1 : -1);
                 return direction * repelForce * forceMag;
             }
             return 0; // No force if far away or exactly on wall
        }
    
        function updatePuck() {
            puck.x += puck.vx;
            puck.y += puck.vy;
    
            // Apply friction
            puck.vx *= friction;
            puck.vy *= friction;
    
            // Speed limit
            let speed = sqrt(puck.vx*puck.vx + puck.vy*puck.vy);
            if (speed > maxPuckSpeed) {
                puck.vx = (puck.vx / speed) * maxPuckSpeed;
                puck.vy = (puck.vy / speed) * maxPuckSpeed;
            }
            // Stop puck if moving very slowly and no one is interacting
            if (speed < 0.1 && !isDragging) { // Check isDragging too
                puck.vx = 0;
                puck.vy = 0;
            }
    
            // Wall Collisions (excluding goal areas)
            let goalPos, goalSize;
            let slightlyMoreFrictionOnWalls = 0.95; // Reduce speed slightly more on wall hits
    
            if (isPortrait) { // Portrait mode collision
                goalPos = width / 2; goalSize = goalWidth;
                let goalLimitLeft = goalPos - goalSize / 2;
                let goalLimitRight = goalPos + goalSize / 2;
    
                // Top wall (AI goal area) collision
                if (puck.y - puck.r < 0) {
                    // Check if NOT within goal posts
                    if (!(puck.x > goalLimitLeft && puck.x < goalLimitRight)) {
                        puck.vy *= wallRestitution; // Reverse Y velocity
                        puck.y = puck.r; // Correct position slightly off wall
                        puck.vx *= slightlyMoreFrictionOnWalls; // Apply extra friction
                    }
                }
                // Bottom wall (Player goal area) collision
                if (puck.y + puck.r > height) {
                     if (!(puck.x > goalLimitLeft && puck.x < goalLimitRight)) {
                        puck.vy *= wallRestitution;
                        puck.y = height - puck.r;
                        puck.vx *= slightlyMoreFrictionOnWalls;
                     }
                }
                // Left wall collision
                if (puck.x - puck.r < 0) {
                    puck.vx *= wallRestitution; // Reverse X velocity
                    puck.x = puck.r;
                    puck.vy *= slightlyMoreFrictionOnWalls;
                }
                // Right wall collision
                else if (puck.x + puck.r > width) {
                    puck.vx *= wallRestitution;
                    puck.x = width - puck.r;
                    puck.vy *= slightlyMoreFrictionOnWalls;
                }
            } else { // Landscape mode collision
                goalPos = height / 2; goalSize = goalWidth;
                let goalLimitTop = goalPos - goalSize / 2;
                let goalLimitBottom = goalPos + goalSize / 2;
    
                // Left wall (Player goal area) collision
                if (puck.x - puck.r < 0) {
                     if (!(puck.y > goalLimitTop && puck.y < goalLimitBottom)) {
                        puck.vx *= wallRestitution;
                        puck.x = puck.r;
                        puck.vy *= slightlyMoreFrictionOnWalls;
                     }
                }
                // Right wall (AI goal area) collision
                if (puck.x + puck.r > width) {
                    if (!(puck.y > goalLimitTop && puck.y < goalLimitBottom)) {
                        puck.vx *= wallRestitution;
                        puck.x = width - puck.r;
                        puck.vy *= slightlyMoreFrictionOnWalls;
                    }
                }
                 // Top wall collision
                if (puck.y - puck.r < 0) {
                    puck.vy *= wallRestitution;
                    puck.y = puck.r;
                    puck.vx *= slightlyMoreFrictionOnWalls;
                }
                // Bottom wall collision
                else if (puck.y + puck.r > height) {
                    puck.vy *= wallRestitution;
                    puck.y = height - puck.r;
                    puck.vx *= slightlyMoreFrictionOnWalls;
                }
            }
    
            // Safety constraint to prevent puck from flying too far out of bounds after goal
            puck.x = constrain(puck.x, -puck.r * 5, width + puck.r * 5);
            puck.y = constrain(puck.y, -puck.r * 5, height + puck.r * 5);
        }
    
        function checkCollisions() {
            // Check player collision first, then AI
            handlePaddleCollision(player);
            handlePaddleCollision(ai);
        }
    
        function handlePaddleCollision(paddle) {
            let dx = puck.x - paddle.x;
            let dy = puck.y - paddle.y;
            let distance = sqrt(dx * dx + dy * dy);
            let minDistance = puck.r + paddle.r;

            if (distance < minDistance && distance > 0.1) {

                // --- 1. Нормаль зіткнення ---
                let normalX = dx / distance;
                let normalY = dy / distance;

                // --- 2. Відносна швидкість ---
                let relativeVelX = puck.vx - paddle.velX;
                let relativeVelY = puck.vy - paddle.velY;

                // --- 3. Швидкість вздовж нормалі ---
                let velocityAlongNormal = relativeVelX * normalX + relativeVelY * normalY;

                // --- 4. Не обробляти, якщо об'єкти вже розлітаються ---
                if (velocityAlongNormal > 0) {
                    let overlap = minDistance - distance;
                    puck.x += normalX * (overlap + 0.1);
                    puck.y += normalY * (overlap + 0.1);
                    return;
                }

                // --- 5. Розрахунок імпульсу ---
                let restitution = 0.8; // Базова пружність
                let impulseMagnitude = -(1.0 + restitution) * velocityAlongNormal;
                const baseHitForce = 2.5;
                impulseMagnitude = max(impulseMagnitude, baseHitForce);
                let paddleSpeedFactor = constrain(sqrt(paddle.velX*paddle.velX + paddle.velY*paddle.velY) * 0.15, 0, 6);
                impulseMagnitude += paddleSpeedFactor;

                // --- 6. **ЗМІНИ ДЛЯ "ЗАЧІПНОГО" УДАРУ КРАЄМ КЛЮЧКИ** ---
                let impulseDirX = normalX;
                let impulseDirY = normalY;
                let blendFactor = 0.30; // Базовий blendFactor

                // **НОВЕ: Перевірка, чи удар ближче до краю ключки**
                const edgeHitThreshold = paddle.r * 0.7; // Поріг "краю" (70% радіуса від центру)
                if (distance > edgeHitThreshold) {
                    console.log("Edge Hit Detected!"); // Для відладки

                    // **Збільшуємо blendFactor для крайових ударів - більше "зачіпки"**
                    blendFactor = 0.7; // Збільшуємо до 0.7 (можна налаштувати)

                    // **Зменшуємо пружність для крайових ударів - менше відскакування**
                    restitution = 0.6; // Зменшуємо пружність до 0.6 (можна налаштувати)
                    impulseMagnitude = -(1.0 + restitution) * velocityAlongNormal; // Перерахунок імпульсу зі зменшеною пружністю
                    impulseMagnitude = max(impulseMagnitude, baseHitForce * 0.8); // Трохи зменшуємо базову силу для країв

                    // **Змінюємо напрямок імпульсу - більше дотичний ефект**
                    // Зміщуємо нормаль трохи в сторону, дотичну до кола ключки
                    let tangentX = -normalY; // Вектор, дотичний до кола (перпендикулярний до нормалі)
                    let tangentY = normalX;

                    // Змішуємо нормаль з дотичним вектором, щоб відхилити напрямок відбиття
                    impulseDirX = lerp(normalX, tangentX, 0.3); // Змішуємо з дотичним на 30% (можна налаштувати)
                    impulseDirY = lerp(normalY, tangentY, 0.3);

                    // Нормалізуємо отриманий вектор напрямку
                    let impulseDirMag = sqrt(impulseDirX*impulseDirX + impulseDirY*impulseDirY);
                    if (impulseDirMag > 0.01) {
                        impulseDirX /= impulseDirMag;
                        impulseDirY /= impulseDirMag;
                    }
                }


                // --- 7. Застосування імпульсу до шайби (з новим напрямком) ---
                puck.vx += impulseMagnitude * impulseDirX; // Використовуємо impulseDirX
                puck.vy += impulseMagnitude * impulseDirY; // Використовуємо impulseDirY


                // --- 8. Обмеження швидкості ---
                let currentSpeed = sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
                if (currentSpeed > maxPuckSpeed) {
                    puck.vx = (puck.vx / currentSpeed) * maxPuckSpeed;
                    puck.vy = (puck.vy / currentSpeed) * maxPuckSpeed;
                }


                // --- 9. Розв'язання перекриття ---
                let overlap = minDistance - distance;
                let pushFactor = 1.1;
                puck.x += normalX * (overlap * pushFactor + 0.1); // Виштовхуємо по нормалі
                puck.y += normalY * (overlap * pushFactor + 0.1);

                // --- Додаткова перевірка після виштовхування (ВИПРАВЛЕНО) ---
                let dx_after = puck.x - paddle.x;
                let dy_after = puck.y - paddle.y;
                let dist_after = sqrt(dx_after*dx_after + dy_after*dy_after); // <--- ДОДАНО ЦЕЙ РЯДОК
                if (dist_after < minDistance) { // Тепер dist_after існує
                    puck.x = paddle.x + normalX * (minDistance + 0.05);
                    puck.y = paddle.y + normalY * (minDistance + 0.05);
                }
            } // Кінець if (distance < minDistance)
        } // Кінець функції handlePaddleCollision


        function checkGoal() {
            let goalCenter, goalSize;
            if (isPortrait) { // Portrait Mode Goals
                goalCenter = width / 2; goalSize = goalWidth;
                let goalLimitLeft = goalCenter - goalSize / 2;
                let goalLimitRight = goalCenter + goalSize / 2;
                // AI Goal (Top edge)
                if (puck.y - puck.r < 0 && puck.x > goalLimitLeft && puck.x < goalLimitRight) {
                    playerScore++;
                    console.log("Player scores!");
                    resetRound(false); // Player scored, AI serves
                }
                // Player Goal (Bottom edge)
                if (puck.y + puck.r > height && puck.x > goalLimitLeft && puck.x < goalLimitRight) {
                    aiScore++;
                     console.log("AI scores!");
                    resetRound(true); // AI scored, Player serves (AI starts on its side)
                }
            } else { // Landscape Mode Goals
                goalCenter = height / 2; goalSize = goalWidth;
                let goalLimitTop = goalCenter - goalSize / 2;
                let goalLimitBottom = goalCenter + goalSize / 2;
                // Player Goal (Left edge)
                if (puck.x - puck.r < 0 && puck.y > goalLimitTop && puck.y < goalLimitBottom) {
                    aiScore++;
                     console.log("AI scores!");
                    resetRound(true); // AI scored
                }
                // AI Goal (Right edge)
                if (puck.x + puck.r > width && puck.y > goalLimitTop && puck.y < goalLimitBottom) {
                    playerScore++;
                     console.log("Player scores!");
                    resetRound(false); // Player scored
                }
            }
        }
    
        function drawBackgroundScore() {
            fill(scoreColor[0], scoreColor[1], scoreColor[2], scoreColor[3]); // Use RGBA for transparency
            let scoreTextSize;
            if (isPortrait) {
                scoreTextSize = width * 0.4; // Adjust size as needed
            } else {
                scoreTextSize = min(width, height) * 0.25; // Adjust size
            }
            textSize(scoreTextSize);
            // Add a subtle stroke for better visibility
            strokeWeight(max(1, scoreTextSize * 0.04));
            stroke(fieldColor[0] * 0.5, fieldColor[1] * 0.5, fieldColor[2] * 0.5, 150); // Darker stroke
            text(`${playerScore} - ${aiScore}`, width / 2, height / 2);
            noStroke(); // Reset stroke settings
        }
    
        function drawField() {
            stroke(200, 200, 200, 180); // Slightly transparent white lines
            strokeWeight(max(2, min(width,height)*0.006)); // Slightly thicker lines
    
            // Center line
            if (isPortrait) {
                line(0, height / 2, width, height / 2);
            } else {
                line(width / 2, 0, width / 2, height);
            }
    
            // Center circle
            noFill();
            ellipse(width / 2, height / 2, min(width,height)*0.2, min(width,height)*0.2); // Slightly larger circle
    
            // Goal lines (visual only)
            let goalCenter, goalSize, gY1, gY2, gX1, gX2;
            strokeWeight(max(3, min(width,height)*0.01)); // Thicker goal lines
            if (isPortrait) {
                goalCenter = width / 2; goalSize = goalWidth;
                gX1 = goalCenter - goalSize / 2; gX2 = goalCenter + goalSize / 2;
                // Player goal line (bottom)
                stroke(playerColor[0], playerColor[1], playerColor[2], 200);
                line(gX1, height, gX2, height);
                // AI goal line (top)
                stroke(aiColor[0], aiColor[1], aiColor[2], 200);
                line(gX1, 0, gX2, 0);
            } else { // Landscape
                goalCenter = height / 2; goalSize = goalWidth;
                gY1 = goalCenter - goalSize / 2; gY2 = goalCenter + goalSize / 2;
                // Player goal line (left)
                stroke(playerColor[0], playerColor[1], playerColor[2], 200);
                line(0, gY1, 0, gY2);
                // AI goal line (right)
                stroke(aiColor[0], aiColor[1], aiColor[2], 200);
                line(width, gY1, width, gY2);
            }
            noStroke(); // Reset stroke
        }
    
        function drawPaddles() {
            // Player Paddle
            fill(player.color[0], player.color[1], player.color[2]);
            // Add a subtle stroke to paddles
            stroke(255, 255, 255, 100); strokeWeight(1.5);
            ellipse(player.x, player.y, player.r * 2);
    
            // AI Paddle
            fill(ai.color[0], ai.color[1], ai.color[2]);
            stroke(255, 255, 255, 100); strokeWeight(1.5);
            ellipse(ai.x, ai.y, ai.r * 2);
            noStroke(); // Reset stroke
        }
    
        function drawPuck() {
            fill(puck.color[0], puck.color[1], puck.color[2]);
            // Add a subtle stroke to puck
            stroke(0, 0, 0, 150); strokeWeight(1);
            ellipse(puck.x, puck.y, puck.r * 2);
            noStroke(); // Reset stroke
        }
    
        function resetRound(aiJustScored) {
            puck.x = width / 2;
            puck.y = height / 2;
    
            // Reset puck velocity - serve towards the player who didn't score
            let serveSpeed = 5; // Slightly faster serve
            if (isPortrait) {
                puck.vx = random(-1.0, 1.0); // Slight horizontal variation
                puck.vy = aiJustScored ? -serveSpeed : serveSpeed; // Serve down if AI scored, up if player scored
            } else {
                puck.vx = aiJustScored ? -serveSpeed : serveSpeed; // Serve left if AI scored, right if player scored
                puck.vy = random(-1.0, 1.0); // Slight vertical variation
            }
    
            // Reset paddle positions to starting points
            if (isPortrait) {
                player.x = width / 2; player.y = height * 0.75;
                ai.x = aiBasePos.x; ai.y = aiBasePos.y; // Reset AI to its base position
            } else {
                player.x = width * 0.25; player.y = height / 2;
                ai.x = aiBasePos.x; ai.y = aiBasePos.y; // Reset AI to its base position
            }
    
            // Reset velocities and previous positions
            player.velX = 0; player.velY = 0;
            player.prevX = player.x; player.prevY = player.y;
            ai.velX = 0; ai.velY = 0;
            ai.prevX = ai.x; ai.prevY = ai.y;
    
            // Reset AI state variables
            ai.stuckInCornerTimer = 0;
            ai.lastPuckPosInCorner = { x: -1, y: -1 };
            ai.isStuckEscaping = false;
    
            // Reset player dragging state
            isDragging = false;
            if (canvasElement) { // Check existence
                canvasElement.removeClass('grabbing');
            }
    
            console.log("Раунд скинуто. Рахунок:", playerScore, "-", aiScore);
        } // End of resetRound function
    
    </script>

</body>
</html>